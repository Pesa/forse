\documentclass[11pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{pdflscape}
\usepackage{multirow}
\usepackage{listings}

\hypersetup{
	breaklinks,
	colorlinks,
	linkcolor=blue,
	pdftitle={Relazione},
	pdfsubject={Relazione sul progetto di Sistemi Concorrenti e Distribuiti},
	pdfauthor={Daniele Battaglia \& Davide Pesavento}
}

\title{Relazione sul progetto}
\author{Daniele Battaglia\\\url{dbat.fk@gmail.com}
	\and Davide Pesavento\\\url{davidepesa@gmail.com}}
\date{}

\newcommand{\term}[2]{\textbf{#1} & #2 \\}
\newcommand{\fun}[1]{\texttt{#1}}

\begin{document}

\maketitle

\tableofcontents

\clearpage

\chapter{Introduzione}
La presente relazione, assieme al software \textsl{FORSE}, è stata realizzata come prova d'esame per il corso "Sistemi Concorrenti e Distribuiti".

I requisiti considerati in fase di progettazione sono stati ricavati da quelli proposti dal docente (\url{http://www.math.unipd.it/~tullio/SCD/2008/Progetto.html})
secondo le clausole di partecipazione di livello 3.

\textsl{Formula One Race Simulation Engine} è realizzato utilizzando i linguaggi \textsl{Erlang} e \textsl{Python}. Per la distribuzione dell'applicazione abbiamo
usato il protocollo di distribuzione Erlang, supportato nativamente dall'omonimo linguaggio e implementato dalla libreria \textsl{TwOTP} per il linguaggio
\textsl{Python}.
Per la creazione di interfacce grafiche è stata utilizzata la libreria \textsl{Qt}.

Nelle fasi di progettazione e realizzazione del prototipo è stata posta maggiore attenzione riguardo le tematiche inerenti distribuzione e concorrenza, nozioni
centrali del corso, a scapito della parte riguardante la correttezza della simulazione da un punto di vista fisico. Abbiamo comunque cercato di includere
gli elementi essenziali della dinamica di una gara automobilistica anche se con alcune semplificazioni.

Nella prima parte del documento verranno esposti i requisiti espliciti, ricavati dalle richieste del docente, ed impliciti, estratti dal contesto reale che il software FORSE deve simulare.
Successivamente verranno elencati i problemi intrinseci che la progettazione del sistema deve affrontare e questi ultimi verranno analizzati alla luce delle conoscenze acquisite durante il corso.
Nella seconda parte della relazione verrà esposta la soluzione trovata, prima a livello progettual/architetturale, poi a livello di implementazione mostrando come i problemi precedentementi trovati vengano risolti in modo soddisfacente dal prototipo.


\chapter{Requisiti}
\begin{enumerate}
    \item Il sistema deve essere composto da più entità concorrenti e distribuite su una rete.
    \item La simulazione evolve in modo deterministico.
    \item Il circuito è suddiviso in settori ed è configurabile dall'utente tramite file di configurazione. Il file contiene le seguenti informazioni:
    \begin{itemize}
        \item[--] tipo di settore (rettilineo, curvilineo, entrata e uscita dai box, intermedio cronometrico, traguardo);
        \item[--] lunghezza e larghezza del segmento;
        \item[--] se il settore è una curva, direzione (destra o sinistra) e raggio di curvatura;
        \item[--] pendenza del suolo;
        \item[--] tempo atmosferico iniziale;
        \item[--] eventuali variazioni del tempo atmosferico nel corso della gara.
    \end{itemize}
    \item Insieme configurabile di concorrenti aventi le seguenti caratteristiche:
    \begin{itemize}
	\item[--] numero identificativo;
	\item[--] nome;
        \item[--] una scuderia di appartenenza;
        \item[--] esperienza/bravura;
        \item[--] peso;
        \item[--] vettura utilizzata.
    \end{itemize}
    \item Parametri di configurazione delle auto:
    \begin{itemize}
        \item[--] capienza del serbatoio;
	\item[--] quantità di carburante presente nel serbatoio a inizio gara;
        \item[--] tipo di pneumatici montato ad inizio gara (da asciutto, intermedio, da bagnato);
        \item[--] potenza del motore;
        \item[--] potenza dei freni;
        \item[--] peso a secco.
    \end{itemize}
    \item Parametri di configurazione di una competizione:
    \begin{itemize}
        \item[--] numero totale di giri da effettuare nella gara;
	\item[--] ordine di partenza dei piloti nella griglia di partenza;
    \end{itemize}
    \item Sistema di controllo (\textit{logging}):
    \begin{itemize}
        \item[--] un pannello generale con posizione dei concorrenti in gara, tempo attuale sul giro e tempo migliore sul giro;
        \item[--] situazione atmosferica della pista;
        \item[--] un pannello per ciascuna scuderia che riporta i parametri tecnici rilevanti delle vetture dei propri piloti (carburante residuo, usura dei pneumatici e loro tipo) nonché i tempi di percorrenza per settore di pista e totali.
    \end{itemize}
\end{enumerate}


%\chapter{\textit{Brainstorming}}
%Finora abbiamo preso in considerazione tre potenziali soluzioni.

%\section*{Soluzione 1}
%Vetture $\Rightarrow$ entità attive \\
%Segmenti del tracciato $\Rightarrow$ entità passive \\

%Per spostarsi da un segmento $S_1$ ad un altro segmento $S_2$ adiacente e successivo a $S_1$, una vettura deve assicurarsi che almeno una corsia di $S_2$ raggiungibile da $S_1$ sia libera, quindi dovrà già essere entrata nella regione protetta di una corsia di $S_2$. Il passaggio sarà completo quando la vettura esce dalla regione protetta di $S_1$ (e questo è un problema non banale). L'entità ``segmento'' espone solo un canale tipato. Le vetture dovranno fornire il numero della corsia da cui provengono e la logica che realizza i sorpassi è implementata nei segmenti effettuando una \texttt{requeue} presso la corsia appropriata.

%\section*{Soluzione 2}
%Segmenti del tracciato $\Rightarrow$ entità attive \\
%Vetture $\Rightarrow$ oggetti che vengono scambiati come parametri \\

%Ciascuna corsia di ciascun segmento è internamente suddivisa in tanti piccoli pezzi, ciascuno dei quali è dotato di una coda contenente le vetture in transito, ordinate per tempo di percorrenza crescente. L'entità ``segmento'' è in ascolto su un canale tipato asincrono, in attesa che il segmento precedente gli invii una nuova vettura. L'attesa prevede un \textit{timeout} pari al minimo tempo di percorrenza di tutte le vettura già accodate su ogni sottosegmento di ogni corsia. Non appena scade il \textit{timeout}, tutte le vetture con tempo di percorrenza pari al \textit{timeout} vengono fatte avanzare al sottosegmento successivo oppure inviate al segmento successivo. Come gestire canali e sorpassi? Usare un \textit{thread pool} per le vetture?

%\section*{Soluzione 3}
%Vetture $\Rightarrow$ entità attive \\
%Segmenti del tracciato $\Rightarrow$ entità passive \\

%Dopo aver calcolato il tempo di uscita della vettura dal segmento $S_i$, esso verrà immediatamente comunicato al segmento $S_{i+1}$ che lo inserirà in un'apposita struttura dati. I canali di ingresso in un settore hanno delle guardie che permettono l'accesso alle vetture solo nell'ordine prestabilito.


\chapter{Problemi}
\subsection*{Avvio del sistema}
La simulazione non può iniziare finché tutte le componenti necessarie non siano state avviate correttamente e siano pronte all'esecuzione. Per esempio la gara non deve iniziare prima che tutte le auto e le scuderie che vi partecipano siano pronte e correttamente inizializzate, altrimenti si potrebbero avere delle inconsistenze nella simulazione. In sostanza è necessario quindi implementare una barriera per la sincronazzizazione di questi processi necessari alla simulazione.

\subsection*{Accesso alla pista}
Le modifiche alle condizioni della pista devono essere eseguite in mutua esclusione per evitare inconsistenze nel suo stato interno, è necessario quindi che i processi che accedono alle informazioni sulla pista eseguano in modo ordinato e solo quando previsto dalla logica di simulazione. Non deve accadere quindi che due auto effettuino contemporaneamente uno spostamento oppure che vengano modificate le condizioni atmosferiche finché un'auto si sta spostando sul tracciato di gara.
La concorrenza deve quindi essere controllata per evitare queste situazioni di race condition.

\subsection*{Sorpassi coerenti}
Quando due auto si trovano a percorrere lo stesso segmento di pista devono interagire in modo realistico. Devono essere quindi chiare e verosimili le condizioni che permettono ad un'auto di sorpassarne un'altra per evitare che si verifichino sorpassi dove la pista o la presenza di altre auto non lo consentano.
\subsection*{Comunicazione di sosta}
Un'auto effettua il rifornimento solo quando richiesto da un attore esterno. Questo attore può essere la scuderia o l'utente.

La scuderia indica all'auto durante quale giro di gara effettuare la sosta in base alle informazioni raccolte sulle performance dell'auto, di conseguenza è possibile che al variare delle condizioni della pista la scuderia calcoli una nuova strategia. Nel caso di un cambiamento delle condizioni atmosferiche per esempio la scuderia può decidere di far rientrare ai box un'auto al fine di montare dei pneumatici adeguati alle nuove condizioni, risulta quindi evidente che il messaggio di sosta può essere più volte e l'auto deve tenere in considerazione solo quello più recente.

L'utente può invece forzare la sosta immediata di un'auto ai box. L'interazione con l'utente avviene in modo asincrono rispetto alla simulazione e deve avere la precedenza sulle direttive provenienti dalla scuderia.

Le situazioni da evitare sono quindi due:
\begin{itemize}
\item Un'auto effettua una sosta ai box sulla base di informazioni non aggiornate,
\item La richiesta di sosta proveniente dall'utente viene ignorata a causa di una successiva ricezione di direttive diverse dalla scuderia.
\end{itemize}

\subsection*{Variazione condizioni atmosferiche}
Le variazioni alle condizioni atmosferiche sono effettuate dal sistema in modo sincrono alla competizione nel caso in cui siano state previste a livello di configurazione oppure possono avvenire a seguito di un'intervento dell'utente in modo asincrono rispetto alla competizione. Il sistema deve quindi permettere di effettuare queste modifiche evitando i problemi di race condition precedentementi evidenziati.

\subsection*{Realismo}
Poiché il prototipo deve simulare una situazione reale bisogna trovare un trade-off adeguato tra la semplicità di implementazione e l'accuratezza della simulazione. Questo vale sia dal punto di vista delle leggi fisiche a cui sono soggette le auto nel percorrere un segmento che dal punto di vista della rappresentazione della pista e delle sue regole di percorrenza. Nella realtà per esempio due auto appartenenti alla stessa scuderia non possono effettuare il rifornimento in contemporanea e devono rispettare i limiti di velocità imposti dal regolamento quando si trovano nella pitlane.

\subsection*{Fine della competizione}
Il sistema deve essere in grado di riconoscere la fine della competizione ovvero quando l'ultima auto in gara taglia il traguardo. In risposta a questo evento il sistema deve reagire in modo opportuno, mettendosi in uno stato che impedisca alla simulazione di procedere.

Deve essere quindi previsto un modo per comunicare a tutte le componenti del sistema di terminare, nel caso in cui non servano più, oppure di mettersi in uno stato di sospensione per permettere all'utente di consultare i dati raccolti durante la simulazione.

\subsection*{Terminazione del sistema}
TODO

\chapter{Architettura del sistema}
In questa sezione verranno descritte a livello funzionale le varie componenti del sistema e classificate secondo il modello visto a lezione.
\begin{landscape}
\begin{figure}
\includegraphics[height=.25\paperheight]{diagrammi/Arch}
\caption{Architettura di sistema}
\label{fig:architettura}
\end{figure}
\end{landscape}

\section{Scheduler}
La componente scheduler ha lo scopo di definire e gestire l'ordine con il quale i processi eseguono quando vanno a modificare i dati relativi alla componente track.
Tali processi possono essere per esempio i processi car che simulano gli spostamenti delle auto durante la gara oppure il processo che gestisce il tempo atmosferico
presente sulla pista.

L'idea di base di questa componente è di mantenere un orologio "logico" unico relativo alla competizione e di permettere l'esecuzione dei soli processi che si sono precendentemente prenotati per eseguire. Si tratta quindi di un sistema di booking nel quale i processi che vengono serviti devono prima indicare a che tempo relativo alla competizione vogliono eseguire e successivamente vengono messi in una coda ordinata secondo il tempo indicato nella prenotazione. Tra i vari processi presenti in questa coda lo scheduler eleggerà per l'esecuzione sempre quello in testa, ovvero il processo che nella fase di prenotazione precedente ha indicato un tempo minore.

Per poter soddisfare le caratteristiche sopra indicate è risultato naturale impostare l'entità scheduler come attiva.
Questa componente ha quindi la funzione di eliminare la parte indesiderata di concorrenza presente nel sistema, per rendere predicibile e controllata l'evoluzione del sistema.
\subsection*{Interfaccia Fornita}
Lo scheduler deve fornire un metodo \fun{queue\_work} che permette alle altre entità attive di effettuare la procedura di booking precedentemente descritta.
Il metodo \fun{set\_speedup} serve a regolare la velocità con cui evolve la simulazione, mentre i metodi \fun{start\_simulation} e \fun{pause\_simulation} servono rispettivamente ad avviare e fermare momentaneamente la simulazione.
\subsection*{Interfaccia Richiesta}
Nessuna.

\section{Track}
La componente track è stata pensata per incapsulare i dati relativi al circuito di gara e le regole di percorrenza del medesimo. Dal punto di vista progettuale track è sicuramente un'entità reattiva, in particolare una risorsa protetta con agente di controllo passivo.
I dati relativi alla configurazione della pista utilizzati dal sistema sono derivati dalle informazioni inserite dall'utente tramite file di configurazione.

La componente track deve contenere due gruppi di dati, uno riguardo le informazioni che possono essere considerate costanti poiché non variano nell'arco della competizione, l'altro comprendente i dati dinamici come la posizione delle vetture durante la gara.
La rappresentazione interna della pista è gestita come una lista di segmenti ciascuno dei quali contiene le seguenti informazioni:
\begin{itemize}
\item lunghezza del tratto,
\item ampiezza del segmento (espressa come numero di corsie),
\item inclinazione,
\item raggio di curvatura (nel caso in cui il segmento sia una curva).
\end{itemize}
Associate ai segmenti si hanno informazioni dinamiche riguardanti lo stato della pista come le condizioni atmosferiche al suolo (che può variare nel corso della competizione).
Un altro gruppo di informazioni dinamiche fondamentali contenute in track è quello relativo alle auto durante la competizione, per ogni auto infatti sono presenti:
\begin{itemize}
\item segmento che sta percorrendo,
\item tempo e corsia di ingresso,
\item tempo e corsia di uscita,
\item velocità di uscita.
\end{itemize}

Oltre ai dati visti finora, la componente track deve anche gestire la logica che determina quali spostamenti siano concessi alle auto e soprattutto secondo quali vincoli tali spostamenti siano possibili. Deve quindi esporre un metodo che permetta alle auto di simulare l'esito di un eventuale spostamento nella pista e un metodo che invece implementi l'effettivo spostamento dell'auto. Fornire un metodo per la simulazione della mossa permette di dare dei dati al chiamante che può quindi scegliere, secondo la sua logica interna e strategia di gara, quale sia la migliore mossa da eseguire e in un momento successivo effettuare tale mossa.
\subsection*{Interfaccia Fornita}
Grazie al metodo \fun{simulate} le entità car possono simulare, una volta scelta la corsia di uscita e espressa la "volontà" o meno di effettuare una sosta in quel giro, l'esito di uno spostamento.

L'utilità di questa funzionalità è evidente se si va a considerare il fatto che, essendo l'informazione ritornata dal metodo \fun{simulate} un'informazione basata sullo stato della pista e non su stime statiche, essa viene influenzata dalla posizione delle altre auto. Una scelta statica ragionevole del percorso migliore da seguire poterebbe essere quella individuata come traiettoria ottimale a circuito vuoto, tuttavia, in questo modo tutte auto seguirebbero lo stesso percorso non riuscendo mai a sorpassarsi.

Avendo a dispozione la posizione degli altri concorrenti è invece possibile per la componente car decidere di discostarsi dalla traiettoria ottimale cambiando corsia (operazione che aumenta il tempo di percorrenza del segmento) per effettuare manovre di sorpasso qualora sia possibile e vantaggioso.

Il metodo \fun{move} necessita degli stessi parametri del metodo \fun{simulate} e serve semplicemente a spostare effettivamente l'auto sul tracciato di gara e ad effettuare le eventuali notifiche di eventi scatenati da tale spostamento.
\subsection*{Interfaccia Richiesta}
Da un punto di vista funzionale la componente track contiene la logica che guida l'erogazione delle operazioni di rifornimento, tuttavia non può decidere quali operazioni effettuare, poiché questo tipo di scelte è inerente la strategia di gara e quindi è da considerarsi a carico della componente team. Di conseguenza track necessita di un metodo \fun{pitstop\_operations} da invocare presso la componente team associata all'auto ai box che abbia come valore di ritorno informazioni su che operazioni di rifornimento da effettuare.

Durante la simulazione, nel momento in cui un'auto effettua uno spostamento, è la componente track che riconosce eventi come un sorpasso o l'attraversamento di un intermedio cronometrico e deve provvedere ad inviare tali notifiche al sistema. La componente track non deve tuttavia incaricarsi di notificare direttamente tali eventi a chi interessato ma, come previsto dall'architettura di sistema, si limita ad inviare le notifiche alla componente event dispatcher e delega a quest'ultima la propagazione di tali informazioni nel sistema.
Le notifiche possibili riguardano:
\begin{itemize}
\item sosta ai box ed operazioni effettuate,
\item ritiro dalla gara di un'auto,
\item attraversamento di un intermedio cronometrico,
\item sorpasso,
\item fine della gara.
\end{itemize}

\section{Car}
Car è un'entità attiva e rappresenta nel contesto del progetto un'auto che partecipa alla competizione. Ad ogni istanza di questa componente presente nel sistema saranno associate queste informazioni:
\begin{itemize}
\item numero identificativo,
\item nome del pilota,
\item abilità del pilota,
\item peso del pilota,
\item scuderia di appartenenza,
\item livello di carburante nell'auto,
\item tipo di pneumatici utilizzati,
\item livello di usura dei pneumatici,
\item posizione nel circuito.
\end{itemize}
Prima dell'inizio della competizione car deve prenotarsi presso lo scheduler e stare poi in attesa del permesso di muoversi sulla pista dato dello scheduler.
Questa componente ha il compito di decidere quale traiettoria adottare per percorrere un segmento e deve farlo basandosi sullo stato dell'auto, sulle direttive dei team e dell'utente e sulle informazioni fornite da track.
\subsection*{Interfaccia Fornita}
L'autorizzazione a muoversi sul circuito di gara viene data a questa componente dallo scheduler attraverso l'invocazione del metodo \fun{move}. L'esecuzione di questo metodo è divisa in due fasi:
\begin{itemize}
\item simulazione, ovvero la fase in cui car utilizza l'interfaccia fornita dalla componente track per simulare tutte le mosse consentite e decidere, secondo la logica che governa la strategia di gara del pilota, quale tra le possibili traiettorie adottare.
\item spostamento, consiste nel segnalare a track la mossa deciso dall'auto e, a fronte delle conseguenze che tale spostamento comporta, prenotarsi nuovamente presso lo scheduler nel caso in cui la mossa vada a buon fine, ritirarsi altrimenti.
\end{itemize}

Per permettere la comunicazione della strategia di gara tra team e car, la presente componente deve esporre nella sua interfaccia un metodo \fun{set\_next\_pitstop} che serve alla scuderia per comunicare al pilota in quale giro recarsi ai box per il rifornimento.

L'utente può anche decidere di forzare il pilota ad effettuare mosse non previste dalla strategia di gara e che non possono essere modificate se non dall'utente stesso, in particolare può:
\begin{itemize}
\item imporre una sosta ai box il prima possibile, per questo viene fornito il metodo \fun{force\_pitstop},
\item forzare il ritiro dalla competizione di un'auto, a tale scopo viene esposto in interfaccia il metodo \fun{retire}.
\end{itemize}
\subsection*{Interfaccia Richiesta}
Questa componente necessita delle funzionalità \fun{simulate} (fase di simulazione) e \fun{move} (fase di spostamento) fornite dalla componente track per poter realizzare il metodo \fun{move} prima descritto.
Durante la fase di inizializzazione del sistema ogni componente car deve notificare i dati di interesse relativi alla sua configurazione al resto del sistema. Questo viene ottenuto grazie al canale \fun{notify} fornito dal event dispatcher.
\section{Team}
Questa componente nel contesto della simulazione rappresenta le scuderie in gara. Team deve quindi ricevere i dati relativi alle prestazioni delle proprie auto e allo stato della pista, elaborare una strategia di rifornimento e comunicare alle auto quando recarsi ai box.

Le decisioni che la logica di questa componente deve prendere sono inerenti le operazioni da eseguire in fase di rifornimento e comprendono la quantità di carburante aggiuntivo da imbarcare e se sostituire o meno i pneumatici ed eventualmente il tipo più appropriato alle condizioni atmosferiche della pista.
\subsection*{Interfaccia Fornita}
Team espone il metodo \fun{pitstop\_operations} nella sua interfaccia con lo scopo di fornire alla componente track, durante la fase di sosta ai box di un'auto, le informazioni necessarie ad effettuare le operazioni di rifornimento.

Il metodo \fun{update} serve a fornire un canale di comunicazione che l'event dispatcher usa per la notifica di eventi relativi alla gara considerati importanti per le scuderie.
\subsection*{Interfaccia Richiesta}
Per poter comunicare la strategia di gara decisa alle auto appartenenti alla scuderia rappresentata, questa componente necessita del metodo \fun{set\_next\_pitstop} fornito da car.
Come la componente car anche team deve comunicare le proprie informazioni di configurazione al sistema tramite il metodo \fun{notify} del event dispatcher.
\section{Event Dispatcher}
Questa componente ha il compito di ricevere tutti i dati relativi alla competizione e, dopo una eventuale rielaborazione, inviare tali dati alle componenti interessate.

Questo tipo di comunicazione segue il modello publish/subscribe ed è quindi previsto che le componenti del sistema interessate a tali dati effettuino prima la procedura di subscription (ricevendo se necessario lo stato attuale della competizione) per poi ottenere aggiornamenti con l'evolvere della gara. I subscribers devono indicare che informazioni desiderano ricevere di modo che l'event dispatcher possa effettuare una procedura di filtering per evitare l'invio di dati non necessari.

Viste le caratteristiche che deve avere tale componente, nell'ottica di un sistema distribuito, possiamo considerarla un server.
\subsection*{Interfaccia Fornita}
Il dispatcher deve fornire metodi di interfaccia verso due insiemi di attori:
\begin{itemize}
\item subscribers, ovvero i processi che si registrano per ottenere le informazioni riguardanti la gara attraverso il metodo \fun{subscribe},
\item notifiers, ovvero quei processi che scatenano eventi inerenti la competizione e delegano la notifica al sistema di tali eventi all'event dispatcher tramite l'invocazione del metodo \fun{notify}.
\end{itemize}
Il metodo \fun{subscribe} prevede che il processo chiamante indichi tra i parametri anche una funzione di callback che faccia da canale per l'invio delle notifche di gara.

\subsection*{Interfaccia Richiesta}
Da un punto di vista puramente pratico non vi è nessuna interfaccia richiesta da questa componente poiché il dispatcher, in assenza di observers, non effettua invocazioni di metodi. Tuttavia abbiamo preferito considerare l'interfaccia richiesta come dinamica, ovvero iniziamlemente vuota e che acquisisce metodi all'aumentare del numero di subscribers. Al momento della registrazione i subscribers devono indicare al dispatcher quale metodo di callback utilizzare e che va quindi ad aggiungersi all'interfaccia richiesta della presente componente.
\section{Weather}
Weather è la componente del sistema addetta a gestire le condizioni meteo iniziali sulla pista e le variazioni di tali condizioni durante la competizione. Le variazioni alla situazione meteo sono decise dall'utente tramite file di configurazione e possono essere decise a simulazione avviata in modo asincrono tramite interfaccia utente.

Poiché questa entità attiva va a modificare lo stato della pista, essa è evidentemente in concorrenza con le entità car presenti nel sistema. E' pertanto necessario che l'accesso alla risorsa track avvenga in modo controllato, in particolare è previsto che le modifiche sulla pista avvengano attraverso booking presso lo scheduler.
\subsection*{Interfaccia Fornita}
Al momento della prenotazione presso lo scheduler questa componente indica il metodo \fun{apply\_change} come metodo di callback, di conseguenza, nel momento in cui lo scheduler permetterà a questa entità di eseguire invocherà tale metodo. Questo metodo ha il compito di cambiare il tempo atmosferico di track secondo quanto definito dall'utente.
L'altro metodo che l'interfaccia di weather espone è \fun{schedule\_change} che serve per impostare eventuali variazioni nel tempo atmosferico da parte dell'utente a simulazione avviata.
\subsection*{Interfaccia Richiesta}
Conformemente a quanto visto finora anche la modifica del tempo atmosferico necessita dell'autorizzazione dello scheduler per essere portata a termine poiché modifica lo stato di track. Di conseguenza tutte le modifiche saranno procedute da un'invocazione del metodo \fun{queue\_work} dello scheduler per assolvere alla fase di prenotazione.

Le condizioni atmosferiche sono un fattore importante per la simulazione e una variazione delle medesime può essere di interesse a diverse componenti del sistema. Per questo motivo ogni volta che viene invocato il metodo \fun{apply\_change} viene notificata la modifica grazie al metodo \fun{notify} dell'event dispatcher.
\section{Debug Log}
Questa componente è pensata principalmente per essere d'ausilio nella fase di sviluppo e test. In fase di inizializzazione effettua la procedura di subscription presso l'event dispatcher per tutti i tipi di messaggi in modo da rendere i dati disponibili in formato testuale tramite una semplice interfaccia grafica.
\subsection*{Interfaccia Fornita}
Al fine di poter riceve le notifiche dall'event dispatcher questa componente espone in interfaccia un metodo callback che serve a ricevere le notifiche e mostrare le informazioni trasportate in forma testuale all'utente.
\subsection*{Interfaccia Richiesta}
Facendo parte del gruppo di componenti observers, debug log necessita della possibilità di registrarsi presso l'event dispatcher con il metodo \fun{subscribe}.
\section{Race Info}
Questa componente serve a raggruppare la maggior parte delle funzionalità di visualizzazione della competizione e permette inoltre all'utente di interagire con il sistema.

I dati visualizzati devono essere sufficienti all'utente per comprendere l'andamento della gara. Devono quindi essere presenti:
\begin{itemize}
\item stato della simulazione (avviata, in pausa, terminata),
\item posizione delle auto sulla pista,
\item classifica e sorpassi,
\item eventuali ritiri,
\item velocità massima,
\item tempo migliore sul giro.
\end{itemize}
Attraverso questa componente l'utente può interagire con lo stato della simulazione nei seguenti modi:
\begin{itemize}
\item avvio,
\item pausa,
\item terminazione,
\item cambio del fattore di speedup.
\end{itemize}
\subsection*{Interfaccia Fornita}
Essendo race info una GUI dal punto di vista funzionale espone sicuramente un'interfaccia verso l'utente con lo scopo di rendere facilmente fruibili i dati riguardanti l'evolvere della simulazione.
Questa componente, conformemente a quanto avviene nel resto del sistema, riceve le informazioni sulla competizione dall'event dispatcher. Per questo motivo deve fornire al dispatcher almeno un canale di comunicazione (metodo di callback).
\subsection*{Interfaccia Richiesta}
Per poter interagire con la simulazione come descritto precendentemente race info necessita di diversi metodi forniti della componente scheduler:
\begin{itemize}
\item \fun{start\_simulation},
\item \fun{pause\_simulation},
\item \fun{set\_speedup}.
\end{itemize}
Appartenendo inoltre al gruppo degli observers questa componente necessita del metodo del event dispatcher \fun{subscribe}.
\section{Team Gui}
Questa componente è un'interfaccia grafica che serve a fornire all'utente dettagli approfonditi sulle statistiche di gara delle auto appartenenti ad una scuderia.
I dati da mostrare all'utente sono:
\begin{itemize}
\item nome del pilota,
\item carburante residuo,
\item consumo medio di carburante sull'ultimo giro,
\item tipo e stato dei pneumatici,
\item usura media dei pneumatici sull'ultimo giro,
\item tempo migliore per intermedio cronometrico,
\item tempo migliore sul giro,
\item numero di pitstop effettuati,
\item operazioni effettuate durante l'ultima sosta ai box.
\end{itemize}
L'utente può inoltre forzare la sosta ai box o il ritiro per un'auto appartenente alla scuderia.
\subsection*{Interfaccia Fornita}
\subsection*{Interfaccia Richiesta}
\section{Weather Station}
Questa componente è un'interfaccia grafica che mostra all'utente le condizioni atmosferiche sulla pista e permette a quest'ultimo di modificarle in modo asincrono rispetto alla simulazione durante il corso della competizione. Le informazioni sullo stato della pista sono ottenute dall'event dispatcher mentre le richieste di variazioni vengono inviate alla componente weather.

\subsection*{Interfaccia Fornita}
\subsection*{Interfaccia Richiesta}
\section{Avvio e Terminazione}
Per rendere più usabile il prototipo abbiamo pensato di far svolgere l'avvio e la configurazione del sistema tramite interfaccia grafica.
L'utente dovrà interagire con due tipi di interfacce di configurazione:
\begin{itemize}
\item Control Panel: serve per permettere all'utente di inserire il percorso dei file di configurazione necessari, per avviare e terminare il sistema.
\item Node Configurator: serve all'utente per indicare al sistema dove possono essere avviate le componenti essenziali del sistema e per deteriminare quindi come saranno distribuite sulla rete tali componenti.
\end{itemize}
Per gestire l'avvio e la terminazione del sistema in modo indipendente dalla distribuzione delle componenti di simulazione abbiamo deciso di associare ad ogni nodo che partecipa al sistema un processo per il controllo del nodo stesso. Vi sarà quindi un nodo ``centrale'' ovvero quello controllato da bootstrap\_server e dei nodi secondari gestiti da node\_manager.

Questi processi di controllo non devo terminare finché il nodo serve al sistema poiché hanno il compito fondamentale di terminare il nodo erlang alla chiusura del sistema.
\subsection*{Control Panel e Bootstrap Server}
Control panel ha il compito di avviare, una volta ottenute le informazioni necessarie dall'utente, un nodo erlang sul quale far eseguire la componente bootstrap\_server.
Control panel deve rimanere attivo poiché è l'interfaccia che permette all'utente di terminare tutti i nodi del sistema.

La funzione di bootstrap\_server è fondamentale per l'avvio e la terminazione del sistema e di conseguenza non deve essere terminato finché gli altri nodi del sistema sono attivi.

Il suo compito nella fase di avvio è quello di coordinare l'avvio di tutti i nodi appartenti al sistema e di avviare, grazie a node\_manager, le componenti del sistema presso i nodi distribuiti, secondo la disponibilità di tali nodi e le necessità della simulazione.

Il numero di componenti da istanziare per eseguire la simulazione viene derivato dalle informazioni contenute nei file di configurazione. Finché il sistema non conta un numero di nodi con una disponibilità di risorse sufficiente ad ospitare la simulazione, il sistema non può essere avviato.
Una volta che bootstrap\_server ha istanziato nel giusto ordine le componenti necessarie presso i nodi distribuiti la fase di boostrap del sistema può dirsi conclusa.

Una volta effettuata la fase di bootstrap del sistema bootstrap\_server rimane in attesa del comando di terminazione da parte di control panel per coordinare la terminazione dei nodi del sistema distribuiti.

\subsection*{Node Configurator e Node Manager}
Una volta avviato node configurator questo istanzia un nodo erlang che andrà a fare parte del sistema distribuito e ivi avvia node\_manager. L'utente deve indicare tramite node configurator la disponibilità di risorse del nodo erlang appena avviato in modo che node\_manager possa comunicarlo a bootstrap\_server.

La componente node\_manager ha anche il compito di avviare le componenti necessarie alla simulazione indicategli e su delega del bootstrap\_server.

Una volta terminata la fase di bootstrap del sistema, node\_manager deve rimanere in attesa del comando di terminazione del nodo da parte di bootstrap\_server.

\chapter{Implementazione}
\section{Tecnologie utilizzate}
Il prototipo è realizzato in \textit{Erlang} e \textit{Python} con l'utilizzo delle librerie \textit{TwOTP} e \textit{Qt} usate rispettivamente per l'implementazione del protocollo di distribuzione \textit{Erlang} su nodi \textit{Python} e per la costruzione di GUI con il supporto dei bindings \textit{PyQt}.

Di seguito le versioni del software utilizzato:
\begin{center}
\begin{tabular}{c|c}
\textbf{Software} & \textbf{Versione}\\
\hline
Erlang & R13B02\\
\hline
Python & 2.6.4\\
\hline
TwOTP & 0.7\\
Twisted & 9.0.0\\
\hline
PyQt & 4.7\\
Qt & 4.6\\
\end{tabular}
\end{center}

Il criterio che abbiamo usato per decidere se implementare una componente del sistema in Erlang o Python è abbastanza semplice: se la componente comprende un'interfaccia grafica utilizzare Python più le librerie sopra citate, Erlang altrimenti.
\begin{center}
\begin{tabular}{|p{0.2\textwidth}|p{0.3\textwidth}|}
\hline
\multirow{6}{*}{\textbf{Erlang}} & Scheduler\\
& Event Dispatcher\\
& Weather\\
& Track\\
& Team\\
& Car \\
\hline
\multirow{4}{*}{\textbf{Python}} & Race Info\\
& Debug Log\\
& Team GUI\\
& Weather Station\\
\hline
\end{tabular}
\end{center}
\subsection*{Caratteristiche di Erlang}
\textit{Erlang} è un linguaggio di programmazione funzionale concorrente \textit{general-purpose} con \textit{dynamic typing}. Per recuperare parte dei controlli statici sul codice abbiamo deciso di utilizzare anche \textit{Dialyzer}, un tool di analisi statica per \textit{Erlang}.

I processi \textit{Erlang} sono estremamente leggeri dal punto di vista dell'occupazione memoria e per questo il linguaggio si presta bene ad applicazioni che usano un gran numero di processi concorrenti. Non vi è memoria condivisa e i processi comunicano tramite scambio di messaggi asincrono.

La macchina virtuale Erlang è detta anche nodo Erlang e un sistema Erlang distribuito è composto quindi da una rete di nodi Erlang. Il protocollo di distribuzione usato nel progetto è il protocollo di distribuzione Erlang che permette la comunicazione tra due nodi Erlang in rete grazie anche al EPMD (Erlang Port Mapper Daemon) avviato automaticamente al bootstrap di ogni nodo. Oltre a questo protocollo nativo, Erlang supporta anche CORBA v 2.0 tramite il modulo Orber.

Una delle caratteristiche più apprezzabili e utili di questo linguaggio è che i processi residenti su nodi differenti comunicano tra di loro esattamente allo stesso modo in cui comunicano due processi sullo stesso nodo. Questa caratteristica permette quindi di passare facilmente dal concorrente al distribuito e viceversa in modo trasparente al programmatore.
\subsection*{Mnesia}
Mnesia è un database distribuito per \textit{Erlang} che supporta sia copie RAM che copie persistenti e permette di salvare strutture dati complesse a piacere. Nel prototipo è stato utilizzato in diverse componenti per salvare dati relativi allo stato della componente stessa.

Il linguaggio usato per le query è \textit{Erlang} stesso, differentemente da quanto avviene per altri linguaggi e DBMS, e questo rende decisamente più omogeneo e leggibile il codice. Ovviamente Mnesia supporta le transazioni e per di più in un modo molto semplice da usare e che sfrutta a pieno la natura funzionale del linguaggio. L'esecuzione di una transazione avviene infatti grazie alla chiamata \fun{mnesia:transaction(F)} dove F è la funzione che contiene le istruzioni da eseguire in modo atomico.
\subsection*{Interazione Erlang-Python: TwOTP}
TwOTP, Twisted interface to Erlang OTP, è una libreria che implementa il protocollo di distribuzione \textit{Erlang} in linguaggio \textit{Python} con l'ausilio di \textit{Twisted}.

\textit{Twisted} è un framework scritto in \textit{Python} per sviluppare applicazioni che interagiscono con la rete fornendo al programmatore un solido e flessibile networking engine ad eventi.

In questo modo è possibile per un'applicazione \textit{Python} interagire coerentemente con nodi \textit{Erlang} attraverso l'uso dell'EPMD.

\subsection*{Eventuali problemi riscontrati}
Il fatto che due processi comunichino allo stesso modo, indipendentemente dal fatto che siano sullo stesso nodo o su nodi differenti, non è del tutto corretto. Vi è infatti una differenza tra le garanzie offerte dal linguaggio riguardo le chiamate asincrone in locale e in distribuito.

L'ordine di invio di messaggi asincroni tra due processi può differire dall'ordine di arrivo degli stessi messaggi nel caso in cui tali processi si trovino su nodi differenti, mentre è garantito essere uguale nel caso in cui i due processi comunicanti si trovino sullo stesso nodo.

Questo può essere considerato un problema in quanto è l'unico aspetto del linguaggio che impone dei vincoli per quanto riguarda la distribuzione delle varie componenti e deve essere considerato quindi in fase di progettazione architetturale.
\section{Dinamiche della competizione}
\subsection{Partenza}
Prima che l'utente dia il via alla competizione tutte le auto devono essersi registrate presso lo scheduler indicando come tempo di prenotazione 0.
E' importante precisare che in questa situazione l'ordine in cui lo scheduler fa eseguire i processi car non influenza l'esito della gara infatti alla partenza le auto sono tutte su segmenti diversi e di conseguenza non conocorrono tra di loro per l'accesso ad uno stesso segmento. Ne deriva quindi che sebbene l'ordine di esecuzione alla partenza possa essere considerato casuale (dipende dall'ordine di registrazione presso una componente distribuita del sistema), questo non va ad influenzare i tempi di percorrenza dei segmenti da parte delle auto e non influisce quindi con il risultato della gara.
La disposizione iniziale delle auto sulla pista avviene similmente a quanto riportato in figura \ref{fig:startGrid}, ed è richiesto all'utente che nella zona di pista che precede la linea di arrivo vi siamo almeno tre corsie.
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/StartGrid}
\caption{Griglia di Partenza}
\label{fig:startGrid}
\end{figure}
\subsection{Percorrenza di un Segmento}
\label{txt:percorrenza}
Nel momento in cui un'auto si appresta a percorrere un segmento sono noti:
\begin{itemize}
\item Corsia di ingresso,
\item Velocità di ingresso,
\item Tempo di ingresso,
\item Conformazione e stato del segmento,
\item Caratteristiche e stato dell'auto,
\item Informazioni su altre auto che stanno percorrendo quel segmento.
\end{itemize}
Grazie alle informazioni sopra elencate e indicando in quale corsia il pilota vuole trovarsi all'uscita del segmento è possibile calcolare il tempo e la velocità di uscita dell'auto. Sono principalmente due i gruppi di fattori che influenzano questo calcolo: in primo luogo l'auto e le caratteristiche della pista, poi la presenza di altre auto nello stesso segmento e l'interazione che queste auto possono avere.

Iniziando ad analizzare il primo gruppo di fattori risulta evidente che vi è una velocità massima che un'auto può mantenere in un segmento per evitare di uscire di pista, in particolare nei segmenti curvilinei la forza di attrito deve essere sufficiente a contrastare la forza centrifuga.
Visto che la forza d'attrito dipende anche dalle caratteristiche e dallo stato dell'auto è evidente che tale velocità massima può essere diversa per ogni auto.
Un altro vincolo alla velocità è dato dal regolamento di gara per quanto riguarda la percorrenza della pitlane, tuttavia questo vincolo non riguarda l'intero segmento ma solo una determinata corsia e va a influire solo sulle auto che stanno per rientarare ai box per effettuare una sosta.

I segmenti appena elencati non sono tuttavia gli unici ad avere un limite alla velocità alla quale possono essere percorsi, basta pensare alle azioni che i piloti effettuano prima di intraprendere una curva nella realtà per capire che un segmento curvilineo impone vincoli alla velocità di percorrenza anche a sui segmenti che lo precedono. E' quindi corretto affermare che ogni segmento della pista ha un limite di velocità, sia esso diretto o indiretto. Il numero di segmenti che impone limiti di velocità diretti può cambiare in base al fatto che il pilota voglia o meno effetuare una sosta ai box e di conseguenza cambieranno anche i limiti indiretti. Per questo motivo abbiamo deciso di modellare questo fatto associando ad ogni segmento due limiti di velocità.

La fase in cui vengono calcolati i due limiti di velocità per ogni segmento della pista è detta fase di preelaborazione e viene effettuata da un'auto:
\begin{enumerate}
\item All'inizio della gara,
\item Ogni volta che passa per il traguardo,
\item Dopo ogni sosta ai box,
\item Dopo ogni cambio delle condizioni atmosferiche.
\end{enumerate}
Il calcolo al punto 1 avviene poiché non è possibile per un'auto effettuare una mossa senza avere una tabella di preelaborazione, al punto 2 per avere una stima più accurata dei valori necessari che consideri il livello di carburante e usura pneumatici attuale e ai punti 3 e 4 poiché in corrisponedenza di tali eventi può cambiare di molto l'attrito pneumatici/pista e invalidare quindi la preelaborazione precedente.

Nel calcolo dei limiti di velocità indiretti è molto importante la decelerazione massima che un'auto può avere per rendere la simulazione più verosimile abbiamo deciso di trattare in modo abbastanza dettagliato la parte fisica della competizione facendo dipendere accelerazione e decelazione massime di un'auto sia dalle caratteristiche dell'auto che da quelle della pista.
In particolare l'accelerazione/decelerazione che un auto può erogare in un determinato segmento dipende da:
\begin{itemize}
\item Potenza del motore/dei freni,
\item Peso dell'auto a secco,
\item Peso del pilota,
\item Peso del carburante,
\item Stato di usura e tipo dei pneumatici,
\item Condizioni atmosferiche,
\item Inclinazione della pista.
\end{itemize}

Passiamo ora a descrivere le operazioni che il processo car effettua nel momento in cui lo scheduler gli consente di eseguire una mossa.
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/Simulation}
\caption{Fase di Simulazione}
\label{fig:simulation}
\end{figure}
Come si può vedere in figura \ref{fig:simulation}, la prima operazione che viene effettuata è l'eventuale ricalcolo della tabella di preelaborazione, successivamente viene controllato se è prevista una sosta ai box per il giro corrente e poi si passa alla fase di simulazione.
Nella fase di simulazione car richiede a track quali sono le corsie raggiungibili nel segmento che sta per percorrere e successivamente di simulare l'esito dello spostamento per ogni corsia che l'auto può raggiungere.
La fase di simulazione, implementata con l'invocazione di track:simulate, può ritornare diversi risultati a car:
\begin{itemize}
\item race\_ended: l'auto nella mossa precedente ha superato il traguardo nell'ultimo giro e ha quindi terminato la sua gara,
\item fail: l'auto non può effettuare la mossa richiesta poiché:
  \begin{itemize}
  \item ha esaurito il carburante;
  \item i pneumatici sono esplosi per l'eccessiva usura,
  \item i team hanno ordinato il ritiro dell'auto dalla competizione,
  \item non è possibile usare la corsia richiesta poiché il regolamento lo vieta,
  \item si sta cercando di entrare nella pitlane senza aver segnalato la sosta,
  \item la corsia che si vuole usare è già occupata e la capacità di frenata dell'auto non è sufficiente ad accodarsi all'auto che la precede,
  \item l'auto non è in grado di mantenersi in pista a causa della velocità eccessiva.
  \end{itemize}
\item pits: l'auto effettuerà una sosta ai box,
\item Time: il tempo in cui l'auto uscirà da quel segmento calcolato come tempo di ingresso più tempo di percorrenza.
\end{itemize}
Una volta ottenuti i risultati della simulazione la logica di car decide quale sia la corsia migliore per effettuare lo spostamento, in particolare l'auto sceglierà la corsia la cui simulazione ritorna il valore (in ordine di priorità):
\begin{itemize}
\item race\_ended,
\item pits,
\item il valore Time minore,
\item fail.
\end{itemize}

\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/Move}
\caption{Fase di Spostamento}
\label{fig:move}
\end{figure}

Una volta scelta la corsia migliore car effettua lo spostamento sulla pista grazie all'invocazione track:move (figura \ref{fig:move}) e resta in attesa del risultato che può essere o il tempo di uscita dal segmento che si sta percorrendo oppure race\_ended oppure fail. Nel primo caso l'auto provvederà a prenotarsi presso lo scheduler indicando il tempo di uscita, negli altri casi car non effetturà alcuna prenotazione.

La fase di spostamento nella prima parte è molto simile alla fase di simulazione poiché viene controllato se la mossa è consentita o meno e viene eventualmente calcolato il tempo di uscita anche nel caso in cui si tratti di una sosta ai box. Nella seconda parte dello spostamento vengono emesse eventuali notifiche verso il dispatcher.

Il metodo move\_car è particolamente importante ai fini della simulazione poiché serve a individuare eventuali sorpassi avvenuti all'interno del segmento e notificarli. Individuare le auto sorpassate a seguito della mossa che un'auto (chiamiamola A) sta effettuando è semplice: detto $T_{en_X}$ il tempo di ingresso di un'auto X nel segmento e $T_{ex_X}$ il suo tempo di uscita, l'insieme delle auto $\mathcal{S}$ sorpassate da A in quel segmento sarà:
\begin{center}
$\mathcal{S} = \{ X \; | \; T_{en_X} \leq T_{en_A} \; \wedge \; T_{ex_X} > T_{ex_A}\}$
\end{center}
Oltre a ciò deve anche calcolare i consumi dell'auto derivanti dall'aver percorso quel segmento.
Il consumo di carburante è pari a una quantità fissa per segmento moltiplicata per un coefficiente derivante dall'inclinazione della pista in quel punto, mentre il consumo dei pneumatici dipende dalla curvatura del segmento, dal tipo di pneumatici usati e dalle condizioni atmosferiche.

\begin{center}
\begin{figure}
\includegraphics[width=0.5\textwidth]{diagrammi/Surpass}
\caption{Interazione tra auto nello stesso segmento}
\label{fig:surpass}
\end{figure}
\end{center}
La figura \ref{fig:surpass} rappresenta le situazioni che si possono creare nel momento in cui un'auto percorre un segmento di pista in cui è presente un altra auto.

Nel momento in cui l'auto A effettua il suo turno sono noti:
\begin{itemize}
\item $T_{en_B}^{n+1}$: il tempo di ingresso di B nel segmento $n+1$,
\item $T_{ex_B}^{n+1}$: il tempo di uscita di B dal segmento $n+1$,
\item $L_{en_B}^{n+1}$: la corsia di ingresso di B nel segmento $n+1$,
\item $L_{ex_B}^{n+1}$: la corsia di uscita di B dal segmento $n+1$,
\item $T_{en_A}^{n+1}$: il tempo di ingresso di A nel segmento $n+1$,
\item $L_{en_A}^{n+1}$: la corsia di ingresso di A nel segmento $n+1$,
\item $L_{ex_A}^{n+1}$: la corsia di uscita di A dal segmento $n+1$ (scelta dall'auto quindi si può considerare fissata).
\end{itemize}
L'algoritmo deve quindi calcolare $T_{ex_A}^{n+1}$.
$T_{lc}$ è il tempo che un'auto impega a spostarsi da una corsia ad una adiacente è considerato fisso ed uguale per tutte le auto, ogni auto può spostarsi di una sola corsia per ogni segmento e, per semplificare la simulazione, si assume che lo spostamento venga effettuato solamente all'ingresso del segmento.
Come precodizione si ha inoltre che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1}$ poiché B si è spostata in quel segmento prima di A e che $T_{en_A}^{n+1} \leq T_{ex_B}^{n+1}$ altrimenti lo scheduler eleggerebbe B per l'esecuzione.

Per poter calcolare il tempo di uscita di A dal segmento $n+1$ è necessario prima valutare se B interferisce con la mossa di A.
Considerando la situazione (a) di figura \ref{fig:surpass} possiamo distinguere due casi:
\begin{enumerate}
\item $L_{ex_A}^{n+1} = m+2$: non vi è alcuna interferenza da parte di B poiché la corsia $m+2$ è libera,
\item $L_{ex_A}^{n+1} = m+1$:
  \begin{enumerate}
  \item $L_{en_B}^{n+1} = m+2$: A sta seguendo esattamente la stessa traiettoria che ha seguito B per percorrere il segmento $n+1$ ed è quindi corretto che a l'auto A si accodi a B e non possa superarla,
  \item $L_{en_B}^{n+1} = m+1$: A cerca di inserirsi davanti a B tagliandole la strada tuttavia, visto che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1}$, vale anche che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1} + T_{lc}$ e non è quindi possibile che A si posizioni davanti a B.
  \item $L_{en_B}^{n+1} = m$: A e B si spostano entrambe sulla stessa corsia $m+1$ provenendo da corsie differenti ma visto che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1}$ allora vale anche $T_{en_B}^{n+1} + T_{lc} \leq T_{en_A}^{n+1} + T_{lc}$ e di conseguenza A può solo accodarsi a B.
  \end{enumerate}
\end{enumerate}

Per quanto riguarda la situazione (b) di figura \ref{fig:surpass} vi sono due casi:
\begin{enumerate}
\item $L_{ex_A}^{n+1} = m+2$ o $L_{ex_A}^{n+1} = m$: non vi è alcuna interferenza da parte di B poiché le corsie sono libere,
\item $L_{ex_A}^{n+1} = m+1$:
  \begin{enumerate}
  \item $L_{en_B}^{n+1} = m+1$: A si accoda a B (vedi caso 1(a) della situazione (a)),
  \item $L_{en_B}^{n+1} = m+2$ o $L_{en_B}^{n+1} = m$: A cerca di inserirsi davanti a B prima che questa le ha tagli la strada e se $T_{en_B}^{n+1} + T_{lc} < T_{en_A}^{n+1}$ vuol dire che non ci riesce e deve quindi accodarsi a B, altrimenti vuol dire che riesce a rimanere in testa e non viene quindi influenzata dalla presenza di B.
  \end{enumerate}
\end{enumerate}

Nei casi in cui non vi è interferenza da parte di B nella mossa di A, $T_{ex_A}^{n+1}$ viene calcolato solo sulla base delle caretteristiche dell'auto e della pista.
Nei casi in cui A deve accodarsi a B viene aggiunto il vincolo che $T_{ex_A}^{n+1} > T_{ex_B}^{n+1}$ e calcolata la velocità di uscita di conseguenza.

\subsection{Intermedi Cronometrici}
Gli intermedi cronometrici e il traguardo sono dei particolari segmenti a lunghezza zero, dal punto di vista di car sono trattati esattamente come tutti gli altri segmenti in quanto è compito di track nascondere le differenze ed effettuare semplificazioni dove possibile. Avendo lunghezza zero non è necessario effettuare il calcolo del tempo di percorrenza infatti per questo tipo di segmenti vale, detto $n+1$ l'indice di tale segmento:
\begin{itemize}
\item $L_{ex_A}^{n} = L_{ex_A}^{n+1}$: imposto dal modulo access poiché non è possibile cambiare corsia in un segmento di lunghezza nulla,
\item $T_{ex_A}^{n} = T_{en_A}^{n+1} = T_{ex_A}^{n+1}$: poiché il tempo impegato a percorrere un tratto di lunghezza nulla è nullo,
\item la velocità di uscita dal segmento $n+1$ è uguale alla velocità di ingresso nel medesimo segmento,
\item non possono avvenire sorpassi all'interno di tale segmento,
\item il percorrere tale segmento non causa consumo né di carburante né di pneumatici.
\end{itemize}
Come si può notare in figura \ref{fig:move} in corrispondenza del transito di un'auto attraverso un intermedio cronometrico viene emessa da track una chrono\_notif verso il dispatcher. Questo tipo di messaggio contiene:
\begin{itemize}
\item ID dell'auto,
\item ID dell'intermedio e numero del giro,
\item tempo di gara in cui l'auto attraversa l'intermedio,
\item velocità massima raggiunta dall'auto dopo l'intermedio precedente,
\item stato carburante e pneumatici dell'auto.
\end{itemize}
\subsection{Pit Lane}
\begin{center}
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/PitLane}
\caption{Rappresentazione della zona dei box}
\label{fig:pitLane}
\end{figure}
\end{center}

La sezione di pista indicata dall'utente come zona box attraverso l'impostazione di pitlane\_entrance e pitlane\_exit nel file di configurazione viene rappresentata dalla componente track come mostra la figura \ref{fig:pitLane}. Le corsie con indice maggiore o uguale a n sono quelle indicate dall'utente nel file di configurazione mentre le corsie -1 e -2 sono generate in modo automatico in fase di costruzione della pista.

Per ogni team che partecipa alla simulazione viene risevata una zona box diversa della pista (indicata in figura come team area) formata da due segmenti di tipo pitlane e uno di tipo pitstop. Per poter effettuare il rifornimento un'auto deve trovarsi nella corsia di indice -2 del segmento pitstop associato alla sua scuderia.

I segmenti di tipo pre\_pitlane, post\_pitlane, pitlane e pitstop sono soggetti a regole di percorrenza aggiuntive definite nel modulo access:
\begin{itemize}
\item pre\_pitlane: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n,
\item post\_pitlane: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n e viceversa,
\item pitlane: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n e viceversa,
\item pitstop: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n e viceversa, inoltre un'auto non può accedere alla corsia -2 dei segmenti pitstop appartenenti ad altre scuderie.
\end{itemize}

Il regolamento delle gare di formula uno impone un limite di velocità nella corsia dei box, nel caso della simulazione questo limite è applicato nelle corsie di indice -1 e -2 dei segmenti di tipo pitlane e pitstop ed è imposto alle auto nel calcolo della velocità massima eseguito in fase di preelaborazione come precedentemente descritto.
La corsia aggiuntiva nei segmenti di tipo pre\_pitlane e post\_pitlane serve a rappresentare rispettivamente la corsia di decelerazione e la corsia di accelerazione e non sono quindi soggette a particolari limiti di velocità imposti dal regolamento.

\subsection{Rifornimento}
\label{txt:rifornimento}
Per poter effettuare le operazioni di rifornimento e cambio pneumatici un'auto deve trovarsi a percorrere il segmento pitstop associato alla sua scuderia nella corsia di indice -2. Quando car effettua uno spostamento in tale posizione (vedi \fun{track:move}) è la componente track che si incarica di effettuare la chiamata alla componente team associata all'auto per richiedere quali operazioni siano da effettuare sull'auto durante la sosta.

Track invia quindi lo stato carburante e pneumatici dell'auto al team il quale risponde con un messaggio contenente quanto carburante aggiungere e quale tipo di pneumatici montare in caso di cambio gomme, il tutto tramite l'invocazione del metodo \fun{pitstop\_operations} di team.

Le componenti team sono in grado di calcolare questi valori sulla base dei dati ottenuti tramite il dispatcher e derivanti dalle crono\_notif, grazie a questo meccanismo team riesce a calcolare il consumo di carburante e gomme medio sul giro per ogni auto e ad adottare quindi una strategia di rifornimento ragionevole.
Il tempo necessario ad effettuare le operazioni è calcolato da track in base alle operazioni da effettuare.

Visto che ogni scuderia può rifornire una sola auto alla volta il tempo di uscita dell'auto A è calcolato come segue:
\begin{center}
$T_{ex_A} = max(T_{en_A}, T_{ex_B}) + T_{ops}$
\end{center}
dove B è l'auto accodata nello stesso segmento e in corsia -2 con tempo di uscita maggiore (ovvero l'auto che eventuamente precede A nella sosta ai box) e $T_{ops}$ è il tempo necessario ad effettuare le operazioni di rifornimento.


\begin{center}
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/NextPitstop}
\caption{Algoritmo set\_next\_pitstop di car}
\label{fig:nextPitstop}
\end{figure}
\end{center}

Un'auto si reca ai pitstop in risposta a due eventi distinti:
\begin{itemize}
\item su richiesta dell'utente e con effetto immediato,
\item su richiesta dei team, in base ai dati ottenuti nel corso della competizione, indicando il giro a cui l'auto deve recarsi ai box.
\end{itemize}

Il primo tipo di richiesta arriva direttamente dalla componente Team GUI, mentre il secondo tipo arriva da team che comunica con l'auto attraverso l'invio di un messaggio di tipo next\_pitstop in modo asincrono per evitare possibili situazioni di deadlock. Il fatto che il messaggio sia asincrono introduce il problema relativo alla freschezza delle informazioni che il messaggio veicola. Supponiamo infatti di avere una conformazione della pista tale per cui appena prima del segmento pitstop di una scuderia vi sia un segmento di tipo intermediate e supponiamo anche che l'auto A di tale scuderia stia percorrendo la pitlane per effettuare una sosta.
E' possibile che si verifichi la seguente sequenza di eventi:
\begin{enumerate}
\item A percorre il segmento intermediate e viene inviata una chrono\_notif al dispatcher,
\item A percorre il segmento successivo ed effettua la sosta ai pitstop,
\item la chrono\_notif arriva al team di A, il quale in base ai dati ricevuti sullo stato dell'auto (ormai obsoleti a causa del pitstop) decide per esempio di posticipare al giro successivo la sosta ai box,
\item A riceve il messaggio e obbedisce al team rientrando ai box nel giro successivo, effettuando quindi una sosta probabilmente inutile.
\end{enumerate}

La soluzione che abbiamo adottato per evitare questo genere di incongruenze prevede che car e team mantengano un contatore dei pitstop effettuati dall'auto fino a quel momento e che team nel messaggio next\_pitstop inserisca anche il valore di tale contatore. Di conseguenza nel momento in cui l'auto riceve il messaggio può verificare la freschezza delle informazioni in esso contenute ed eventualmente ignorare il messaggio. I messaggi provenienti dall'utente ovviamente non necessitano di tale contatore poiché sono considerati dall'auto sempre corretti.

Lato car l'algoritmo che gestisce l'arrivo di messaggi next\_pitstop è quello rappresentato in figura \ref{fig:nextPitstop}.

Il parametro \fun{new\_stop} presente nel messaggio next\_pitstop può assumere il valore \fun{now} nel caso in cui la sosta sia imposta dall'utente oppure può essere l'indice del giro in cui effettuare pitstop successivo se la sosta è richiesta dalla logica di team. Come si può notare dalla figura viene dato maggior peso alle decisioni dell'utente ignorando i messaggi dei team che potrebbero interferire.

Nello stato interno dell'auto, il campo \fun{next\_stop} può assumere i valori \fun{now}, un intero e \fun{undefined}. Il valore undefined serve ad indicare che non sono state ancora previste soste oppure che l'auto ha appena effettuato un rifornimento e non ha ancora ottenuto direttive dai team o dall'utente.

\subsection{Arrivo}
Un'auto termina la competizione nel momento in cui va a percorrere il segmento successivo al traguardo nell'ultimo giro di gara oppure se esce di pista, come descritto in \ref{txt:percorrenza}. Come si può notare in figura \ref{fig:move}, nel momento in cui un'auto esce dalla competizione viene invocato il metodo \fun{track:remove\_car} e successivamente termina la sua esecuzione.

Tale metodo serve anche a mantenere aggiornato il contatore delle auto ancora in gara interno alla componente track. Nel momento in cui questo contatore raggiunge il valore zero allora la gara è terminata e track può notificare questo evento al resto del sistema inviando al dispatcher la notifica \fun{\#race\_notif\{event = finished\}}.

In questo modo le componenti del sistema non più necessarie possono terminare la loro esecuzione, mentre le componenti grafiche possono disabilitare le funzionalità non più disponibili e restare attiva per permettere all'utente di consultare i dati relativi alla simulazione.
\subsection{Interazione con l'Utente}
L'utente interviene sempre in modo asincrono rispetto alla simulazione tramite le diverse interfacce.
\begin{center}
\begin{tabular}{|l|l|}
\hline
\multirow{4}{*}{\textbf{Race Info}} & Avvio della simulazione\\
& Sospensione della simulazione\\
& Cambio del fattore di speedup\\
& Terminazione del sistema\\
\hline
\multirow{2}{*}{\textbf{Team GUI}} & Imporre sosta ai box ad un'auto\\
& Imporre il ritiro ad un'auto\\
\hline
\textbf{Weather Station} & Modificare le condizioni atmosferiche dei settori\\
\hline
\end{tabular}
\end{center}

L'avvio della simulazione avviene tramite la chiamata \fun{scheduler:start\_simulation} che fa in modo che lo scheduler conceda il permesso di eseguire in modo sequenziale ai processi in coda.

La sospensione della simulazione avviene tramite l'invocazione a \fun{scheduler:pause\_simulation} che inibisce temporaneamente la valutazione della coda e di conseguenza le modifiche alla pista.

La velocità di evoluzione della simulazione può essere alterata dall'utente attraverso il metodo \fun{scheduler:set\_speedup} che va ad agire sul tempo che intercorre tra la fine dell'esecuzione di un'attività presente nella coda e l'inizio di quella successiva, non interferendo quindi in alcun modo con il tempo logico della simulazione.

La terminazione del sistema... FIXME.

L'utente può imporre una sosta ai box ad un'auto attraverso l'interfaccia utente associata alla scuderia a cui tale auto appartiene con l'invocazione al metodo \fun{car:force\_pitstop} che causa l'invio di un messaggio \fun{\#next\_pitstop\{lap = now\}} che viene elaborato da car come descritto in \ref{txt:rifornimento}.

Tramite Team GUI l'utente può imporre il ritiro di un'auto dalla competizione grazie al metodo \fun{car:retire}.
\section{Event Dispatcher}
\begin{landscape}
\begin{figure}
\includegraphics[width=0.75\paperheight]{diagrammi/NotifFlow}
\caption{Diffusione delle notifiche tramite dispatcher}
\label{fig:notifFlow}
\end{figure}
\end{landscape}

In figura \ref{fig:notifFlow}, sulla sinistra si possono vedere quali sono i tipi di notifica presenti nel sistema e da che componenti sono inviati, mentre sulla destra sono rappresentate le componenti che ricevono i dati, eventualmente rielaborati, derivanti dalle notifiche.

Un compito molto importante del dispatcher è quello di mantenere l'ordine delle notifiche rispetto ogni destinazione, non è quindi possibile affidarsi a comunicazione asincrona.
I messaggi in ingresso e in uscita dal dispatcher verso le altre componenti del sistema sono quindi veicolati da chiamate sincrone, tuttavia, al suo interno il dispatcher è composto da più processi che comunicano tra di loro in modo asincrono, mantenendo comunque invariato l'ordine delle notifiche.
Questo è possibile poiché l'ordine di messaggi asincroni tra processi sullo stesso nodo è grantito dal linguaggio. Una funzione fondamentale di questa parte asincrona nel percorso che la notifica deve fare è quella di evitare possibili deadlock intervenendo sulla condizione di attesa circolare. In questo modo, una volta che un processo mittente ha depositato la sua notifica presso il dispatcher non deve bloccarsi in attesa dei processi destinatari ma può continuare la sua esecuzione.
Come si può notare in figura \ref{fig:notifFlow}, per esempio, la componente team compare sia come mittente che come destinatario e se il percorso della notifica fosse totalmente sincrono si avrebbe una situazione di deadlock in cui team, durante la sincronizzanizzazione con il dispatcher, tenta di sincronizzarsi con se stesso ottenendo come risultato un evidente fallimento.
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/Dispatcher}
\caption{Interno del Event Dispatcher}
\label{fig:dispatcher}
\end{figure}

Come si può vedere in figura \ref{fig:dispatcher}, il dispatcher è composto di un processo detto front-end che ha il compito di ricevere ogni notifica in ingresso e spedirla ai back-end interessati in modo asincrono. Oltre a ciò, il front-end deve anche ricevere le richieste di subscription e registrare quindi i processi richiedenti presso il corretto back-end. Al ricevimento di una notifica un back-end provvede ad una eventuale rielaborazione dei dati in essa contenuti per poi inviare il risultato di tale computo ai processi presenti nella sua lista di subscribers.

Poiché è stato previsto che una GUI possa registrarsi a simulazione iniziata è necessario che i back-ends abbiano uno stato interno in modo da poter inviare al processo che si registra un'immagine parziale dello stato della competizione fino al momento della subscription. Successivamente, al processo richiedente, verranno inviate solo le informazioni sul cambiamento relativo allo stato della competizione in modo da evitare l'invio di dati ridondanti.
\chapter{Correttezza}
\section{Avvio del sistema}
TODO
\section{Accesso alla pista}
L'accesso alla componente track è disciplinato dallo scheduler infatti le uniche componenti che vi possono accedere sono car e weather. Ogniqualvolta car o weather necessitino dell'accesso alla risorsa track, essi effettuano la procedura di prenotazione presso lo scheduler a cui è delegato il compito di gestire la modalità di accesso a track.

La componente scheduler utilizza una politica FIFO within priorities per gestire la coda dei processi prenotati assegnando priorità maggiore ai processi che indicano un tempo minore in fase di prenotazione.
Scheduler elegge quindi un solo processo alla volta (la testa della coda) per l'accesso a track e non permette l'accesso ad altri processi. Questo finché il processo che sta utilizzando track non notifica allo scheduler di non aver più bisgno della risorsa.

Scheduler garantisce quindi un accesso sequenziale a track e assicura l'assenza di stati inconsistenti della pista.

\section{Tempo di percorrenza}
Il tempo che un'auto impiega a percorrere la pista è la somma del tempo impegato a percorrere i singoli segmenti ed è calcolato algoritmicamente dalla componente track.

Risulta quindi evidente che il sistema su cui sta eseguendo l'applicazione non influisce minimamente sui tempi di percorrenza delle auto, tantomeno influisce l'orologio di sistema.
Il tempo di percorrenza di un segmento da parte di un'auto è influenzato dagli altri partecipanti solo qualora le traiettorie delle auto si intersechino, come descritto in modo accurato in \ref{txt:percorrenza}.
La procedura di sosta ai box differisce nel calcolo del tempo di percorrenza rispetto agli altri segmenti, tuttavia si integra perfettamente nell'algoritmo citato in precedenza in quanto l'auto rimane comunque soggetta ai meccanismi di uno spostamento generico sulla pista quali il cambio corsia e il sorpasso.

Analizzando l'algoritmo ci si può facilmente convincere che non è possibile che avvenga il fenomeno dello ``scavalcamento'' tra auto.

L'ultima considerazione rigarda l'influenza che il fattore di speedup può avere sulla competizione, ed anche in questo caso è facile convincersi che la velocità con la quale viene eseguita la simulazione non influenza in alcun modo i tempi di percorrenza delle auto.

Il fattore di speedup infatti viene implementato aumentando o riducendo il periodo di pausa che lo scheduler fa trascorrere tra il rilascio della componente track da parte di un processo e la concessione di tale risora ad un'altro.
Tale pausa è introdotta artificialmente per rallentare l'evolvere della simulazione e renderla quindi fruibile dall'utente.

\section{Non determinismo}
Per quanto riguarda il non determinismo a livello di simulazione abbiamo deciso di limitarlo alle sole situazioni in cui esso sia desiderabile.
L'unico caso in cui l'ordine di esecuzione può infatti influire con il risultato della simulazione è quello in cui anche nella realtà non si possa prevedere in modo certo l'esito dell'interazione tra due auto.

\begin{figure}
\includegraphics[width=0.6\textwidth]{diagrammi/NonDet}
\caption{Situazione di non determinismo}
\label{fig:nonDet}
\end{figure}

Consideriamo infatti la situazione riportata in figura \ref{fig:nonDet}, e assumiamo che:
\begin{itemize}
\item le auto e i piloti abbiano caratteristiche identiche,
\item $T_{en_A}^{n+1} = T_{en_B}^{n+1}$: le auto abbiano tempi di ingresso uguali,
\item $V_{en_A}^{n+1} = V_{en_B}^{n+1}$: le auto abbiano velocità di ingresso uguali.
\end{itemize}

Sotto queste ipotesi non vi sono problemi di interazione tra le auto finché $L_{ex_A}^{n+1} \neq L_{ex_B}^{n+1}$ poiché, avendo traiettorie che non si intersecano, i tempi di percorrenza dell'una non sono influenzabili in alcun modo dall'altra.

Se tuttavia si presentasse il caso in cui $L_{ex_A}^{n+1} = L_{ex_B}^{n+1}$ allora vi sarebbe del non determinismo in quanto il tempo di percorrenza del segmento senza considerare l'influenza delle altre auto sarebbe il medesimo, ma le due auto si troverebbero allora a collidere in uscita dal segmento. La prima auto ad eseguire sarà quindi anche la prima auto ad uscire dal segmento e di conseguenza, per quanto visto in \ref{txt:percorrenza}, la seconda auto si dovrà accodare alla prima segnando un tempo di uscita dal segmento leggermente maggiore.

C'è da dire che il verificarsi di tale situazione è altamente improbabile e non è quindi possibile cogliere questo comportamento del sistema in una generica simulazione ma bisogna invece creare una situazione ad-hoc per ottenere dei test ripetibili e poter apprezzare quindi la presenza del non determinismo.

\section{Realismo}
\subsection*{Fisico}
Al fine di ottenere buon livello di realismo della simulazione da un punto di vista fisico abbiamo deciso di far dipendere le performance dell'auto da diversi fattori modellando i fenomeni fisici convoilti nel miglior modo possibile, con particolare attenzione alla decelarazione.

\begin{center}
\begin{tabular}{|l|l|}
\hline
\multirow{5}{*}{Velocità massima in curva} & Raggio di curvatura\\
& Inclinazione del tratto\\
& Condizione atmosferica\\
& Tipo di pneumatici\\
& Usura dei pneumatici\\
\hline
\multirow{8}{*}{Accelerazione/Decelerazione massima} & Potenza del motore/dei freni\\
& Peso dell'auto\\
& Peso del carburante\\
& Peso del pilota\\
& Inclinazione del tratto\\
& Condizione atmosferica\\
& Tipo di pneumatici\\
& Usura dei pneumatici\\
\hline
\multirow{3}{*}{Consumo dei pneumatici} & Raggio di curvatura\\
& Tipo di pneumatici\\
& Condizione atmosferica\\
\hline
Consumo di carburante & Inclinazione del tratto\\
\hline
\end{tabular}
\end{center}

Considerando la fase di decelerazione che un'auto deve intraprendere generalmente prima di entrare in curva o prima di accedere alla pitlane, è stato necessario introdurre nelle meccaniche di simulazione il calcolo della tabella di preelaborazione.
Questo principalmente per evitare che le auto arrivassero all'entrata della curva e, non avendo il tempo di frenare, uscissero di pista sistematicamente.
\subsection*{Dinamiche di gara}
Per quanto riguarda il realismo nelle dinamiche di gara abbiamo considerato la possibilità per un'auto di ritirarsi dalla competizione ed essere quindi rimossa dalla pista a seguito di:
\begin{itemize}
\item Uscita di pista per velocità troppo elevata,
\item Uscita di pista per evitare incidenti qualora l'auto non risca a frenare in tempo per evitare le altre auto,
\item Esplosione pneumatici a causa di un'eccessiva usura,
\item Esaurimento del carburante,
\item Potenza del motore insufficiente a percorrere il tratto.
\end{itemize}

Si è cercato poi di descrivere l'interazione tra le auto in uno stesso segmento in modo preciso, per poter distinguere le condizioni di sorpasso e quelle di accodamento in base anche alla traiettoria di un'auto. Limitare il cambio di corsia ad uno solo per segmento è stato utile per avere un maggior controllo sull'algoritmo di percorrenza di un segmento e sull'aderenza della simulazione alla realtà.

Per avere una simulazione a grana fine abbiamo deciso di impostare la lunghezza di un segmento a 5 metri, in questo modo siamo riusciti anche ad ottenere una presentazione grafica della simulazione abbastanza fluida.

\appendix

\chapter{File di configurazione}
\section*{Team e Car}
Le impostazioni delle scuderie, delle auto e dei piloti sono contenuti in uno stesso file di configurazione.
\begin{lstlisting}
[
        {team_name, "McLaren"},
        {brake, 34000},
        {power, 25000},
        {weight, 650},
        {cars, [
                [{id, 2},
                {name, "Lewis Hamilton"},
                {skill, 6},
                {weight, 68},
                {fuel, 70},
                {tyres, slick}],
                [{id, 6},
                {name, "Heikki Kovalainen"},
                {skill, 4},
                {weight, 62},
                {fuel, 80},
                {tyres, slick}]
                ]}
].
\end{lstlisting}

I parametri di configurazione sono descritti in \textit{Erlang} per risparmiare tempo sfruttando le funzioni di parsing offerte dal linguaggio. Si tratta di una lista di coppie chiave-valore il cui significato è spiegato nella seguente tabella:

\begin{center}
\begin{tabular}{|p{0.15\textwidth}|p{0.75\textwidth}|}
\hline
\multicolumn{2}{|c|}{Scuderia e Auto}\\
\hline
team\_name & Nome della scuderia\\
brake & Potenza dei freni\\
power & Potenza del motore\\
weight & Peso dell'auto a secco\\
cars & Lista dei piloti e della configurazione iniziale delle auto\\
\hline
\multicolumn{2}{|c|}{Pilota e Auto}\\
\hline
id & Posizione nella griglia di partenza\\
name & Nome del pilota\\
skill & Abilità del pilota (intero tra 1 e 10 compresi)\\
weight & Peso del pilota\\
fuel & Carburante presente nell'auto ad inizio gara\\
tyres & Tipo di gomme montate sull'auto ad inizio gara\\
\hline
\end{tabular}
\end{center}

\section*{Track}
Il file di configurazione di track contiene le informazioni riguardanti la conformazione della pista espressa in settori. La configurazione è composta da una lista di tuple, ciascuna delle quali rappresenta un settore.

Di seguito la sintassi per descrivere i tipi di settore possibili e i parametri consentiti.

\begin{itemize}
\item \texttt{\{straight, LEN, MIN\_LANE, MAX\_LANE, INC, RAIN\}}\\ Rettilineo
\item \texttt{\{right, LEN, CURVE\_RAD, MIN\_LANE, MAX\_LANE, INC, RAIN\}}\\ Curva a destra
\item \texttt{\{left, LEN, CURVE\_RAD, MIN\_LANE, MAX\_LANE, INC, RAIN\}}\\ Curva a sinistra
\item \texttt{\{finish\_line\}}\\ Traguardo
\item \texttt{\{intermediate\}}\\ Intermedio cronometrico
\item \texttt{\{pitlane\_entrance\}}\\ Inizio della zona box
\item \texttt{\{pitlane\_exit\}}\\ Fine della zona box
\end{itemize}

\begin{center}
\begin{tabular}{|p{0.2\textwidth}|p{0.7\textwidth}|}
\hline
LEN & Lunghezza del settore in metri, possibilmente un valore multiplo di 5\\
\hline
CURVE\_RAD & Raggio di curvatura in metri\\
\hline
MIN\_LANE & Minimo indice di corsia consentito\\
\hline
MAX\_LANE & Massimo indice di corsia consentito\\
\hline
INC & Inclinazione della pista [-89.9; 89.9]\\
\hline
RAIN & Condizioni atmosferiche all'inizio della gara, un intero tra 0 e 10\\
\hline
\end{tabular}
\end{center}

\section*{Weather}
Questo file contiene una lista di tuple, ciascuna delle quali rappresenta le variazioni del tempo atmosferico in un istante di gara.

Le tuple sono nella forma
\begin{center}
\texttt{\{WHEN, [\{WHERE, RAIN\}, \dots $\;$]\}}
\end{center}
\begin{itemize}
\item \texttt{WHEN}: Quando, rispetto il tempo di gara, avverrà il cabiamento. Può essere espresso in secondi oppure nel formato \{h,m,s\}.
\item \texttt{WHERE}: In che settore avverrà il cambiamento, l'indice si riferisce alla posizione del settore nel file di configurazione della pista.
\item \texttt{RAIN}: Quantità di pioggia presente nel settore, un intero nell'intervallo [0;10].
\end{itemize}


\chapter{Glossario}

\begin{tabularx}{\textwidth}{lX}
\term{Intermedio cronometrico}{}
\term{Tabella di preelaborazione}{Struttura dati riferita ad un'auto in cui sono contenute le triple (ID segmento, velocità massima, velocità massima con pitstop) per ogni segmento della pista.}
\term{Segmento}{L'unità di spazio più piccola e indivisibile che costituisce il tracciato, utilizzata per la rappresentazione interna dello stesso.}
\term{Settore}{Porzione di tracciato che presenta caratteristiche fisiche costanti per tutta la sua lunghezza. Definito dall'utente in fase di configurazione.}
\term{Speedup}{Fattore numerico che serve ad impostare la velocità con la quale la simulazione evolve.}
\end{tabularx}

\end{document}
