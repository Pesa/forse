\documentclass[11pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{pdflscape}

\hypersetup{
	breaklinks,
	colorlinks,
	linkcolor=blue,
	pdftitle={Relazione},
	pdfsubject={Relazione sul progetto di Sistemi Concorrenti e Distribuiti},
	pdfauthor={Daniele Battaglia \& Davide Pesavento}
}

\title{Relazione sul progetto}
\author{Daniele Battaglia\\\url{dbat.fk@gmail.com}
	\and Davide Pesavento\\\url{davidepesa@gmail.com}}
\date{}

\newcommand{\term}[2]{\textbf{#1} & #2 \\}
\newcommand{\fun}[1]{\texttt{#1}}

\begin{document}

\maketitle

\tableofcontents

\clearpage

\chapter{Introduzione}
La presente relazione, assieme al software \textsl{FORSE}, è stata realizzata come prova d'esame per il corso "Sistemi Concorrenti e Distribuiti".

I requisiti considerati in fase di progettazione sono stati ricavati da quelli proposti dal docente (\url{http://www.math.unipd.it/~tullio/SCD/2008/Progetto.html})
secondo le clausole di partecipazione di livello 3.

\textsl{Formula One Race Simulation Engine} è realizzato utilizzando i linguaggi \textsl{Erlang} e \textsl{Python}. Per la distribuzione dell'applicazione abbiamo
usato il protocollo di distribuzione Erlang, supportato nativamente dall'omonimo linguaggio e implementato dalla libreria \textsl{Twotp} per il linguaggio
\textsl{Python}.
Per la creazione di interfacce grafiche è stata utilizzata la libreria \textsl{Qt4}.

Nelle fasi di progettazione e realizzazione del prototipo è stata posta maggiore attenzione riguardo le tematiche inerenti distribuzione e concorrenza, nozioni
centrali del corso, a scapito della parte riguardante la correttezza della simulazione da un punto di vista fisico. Abbiamo comunque cercato di includere
gli elementi essenziali della dinamica di una gara automobilistica anche se con alcune semplificazioni.

Nella prima parte del documento verranno esposti i requisiti espliciti, ricavati dalle richieste del docente, ed impliciti, estratti dal contesto reale che il software FORSE deve simulare.
Successivamente verranno elencati i problemi intrinseci che la progettazione del sistema deve affrontare e questi ultimi verranno analizzati alla luce delle conoscenze acquisite durante il corso.
Nella seconda parte della relazione verrà esposta la soluzione trovata, prima a livello progettual/architetturale, poi a livello di implementazione mostrando come i problemi precedentementi trovati vengano risolti in modo soddisfacente dal prototipo.


\chapter{Requisiti}
\begin{enumerate}
    \item Il sistema deve essere composto da più entità concorrenti e distribuite su una rete.
    \item La simulazione evolve in modo deterministico.
    \item Il circuito è suddiviso in settori ed è configurabile dall'utente tramite file di configurazione. Il file contiene le seguenti informazioni:
    \begin{itemize}
        \item[--] tipo di settore (rettilineo, curvilineo, entrata e uscita dai box, intermedio cronometrico, traguardo);
        \item[--] lunghezza e larghezza del segmento;
        \item[--] se il settore è una curva, direzione (destra o sinistra) e raggio di curvatura;
        \item[--] pendenza del suolo;
        \item[--] tempo atmosferico iniziale;
        \item[--] eventuali variazioni del tempo atmosferico nel corso della gara.
    \end{itemize}
    \item Insieme configurabile di concorrenti aventi le seguenti caratteristiche:
    \begin{itemize}
	\item[--] numero identificativo;
	\item[--] nome;
        \item[--] una scuderia di appartenenza;
        \item[--] esperienza/bravura;
        \item[--] peso;
        \item[--] vettura utilizzata.
    \end{itemize}
    \item Parametri di configurazione delle auto:
    \begin{itemize}
        \item[--] capienza del serbatoio;
	\item[--] quantità di carburante presente nel serbatoio a inizio gara;
        \item[--] tipo di pneumatici montato ad inizio gara (da asciutto, intermedio, da bagnato);
        \item[--] potenza del motore;
        \item[--] potenza dei freni;
        \item[--] peso a secco.
    \end{itemize}
    \item Parametri di configurazione di una competizione:
    \begin{itemize}
        \item[--] numero totale di giri da effettuare nella gara;
	\item[--] ordine di partenza dei piloti nella griglia di partenza;
    \end{itemize}
    \item Sistema di controllo (\textit{logging}):
    \begin{itemize}
        \item[--] un pannello generale con posizione dei concorrenti in gara, tempo attuale sul giro e tempo migliore sul giro;
        \item[--] situazione atmosferica della pista;
        \item[--] un pannello per ciascuna scuderia che riporta i parametri tecnici rilevanti delle vetture dei propri piloti (carburante residuo, usura dei pneumatici e loro tipo) nonché i tempi di percorrenza per settore di pista e totali.
    \end{itemize}
\end{enumerate}


%\chapter{\textit{Brainstorming}}
%Finora abbiamo preso in considerazione tre potenziali soluzioni.

%\section*{Soluzione 1}
%Vetture $\Rightarrow$ entità attive \\
%Segmenti del tracciato $\Rightarrow$ entità passive \\

%Per spostarsi da un segmento $S_1$ ad un altro segmento $S_2$ adiacente e successivo a $S_1$, una vettura deve assicurarsi che almeno una corsia di $S_2$ raggiungibile da $S_1$ sia libera, quindi dovrà già essere entrata nella regione protetta di una corsia di $S_2$. Il passaggio sarà completo quando la vettura esce dalla regione protetta di $S_1$ (e questo è un problema non banale). L'entità ``segmento'' espone solo un canale tipato. Le vetture dovranno fornire il numero della corsia da cui provengono e la logica che realizza i sorpassi è implementata nei segmenti effettuando una \texttt{requeue} presso la corsia appropriata.

%\section*{Soluzione 2}
%Segmenti del tracciato $\Rightarrow$ entità attive \\
%Vetture $\Rightarrow$ oggetti che vengono scambiati come parametri \\

%Ciascuna corsia di ciascun segmento è internamente suddivisa in tanti piccoli pezzi, ciascuno dei quali è dotato di una coda contenente le vetture in transito, ordinate per tempo di percorrenza crescente. L'entità ``segmento'' è in ascolto su un canale tipato asincrono, in attesa che il segmento precedente gli invii una nuova vettura. L'attesa prevede un \textit{timeout} pari al minimo tempo di percorrenza di tutte le vettura già accodate su ogni sottosegmento di ogni corsia. Non appena scade il \textit{timeout}, tutte le vetture con tempo di percorrenza pari al \textit{timeout} vengono fatte avanzare al sottosegmento successivo oppure inviate al segmento successivo. Come gestire canali e sorpassi? Usare un \textit{thread pool} per le vetture?

%\section*{Soluzione 3}
%Vetture $\Rightarrow$ entità attive \\
%Segmenti del tracciato $\Rightarrow$ entità passive \\

%Dopo aver calcolato il tempo di uscita della vettura dal segmento $S_i$, esso verrà immediatamente comunicato al segmento $S_{i+1}$ che lo inserirà in un'apposita struttura dati. I canali di ingresso in un settore hanno delle guardie che permettono l'accesso alle vetture solo nell'ordine prestabilito.


\chapter{Problemi}


\chapter{Architettura del sistema}
In questa sezione verranno descritte a livello funzionale le varie componenti del sistema e classificate secondo il modello visto a lezione.
\begin{landscape}
\begin{figure}
\includegraphics[height=.25\paperheight]{diagrammi/Arch}
\caption{Architettura di sistema}
\label{fig:architettura}
\end{figure}
\end{landscape}

\section{Scheduler}
La componente scheduler ha lo scopo di definire e gestire l'ordine con il quale i processi eseguono quando vanno a modificare i dati relativi alla componente track.
Tali processi possono essere per esempio i processi car che simulano gli spostamenti delle auto durante la gara oppure il processo che gestisce il tempo atmosferico
presente sulla pista.

L'idea di base di questa componente è di mantenere un orologio "logico" unico relativo alla competizione e di permettere l'esecuzione dei soli processi che si sono precendentemente prenotati per eseguire. Si tratta quindi di un sistema di booking nel quale i processi che vengono serviti devono prima indicare a che tempo relativo alla competizione vogliono eseguire e successivamente vengono messi in una coda ordinata secondo il tempo indicato nella prenotazione. Tra i vari processi presenti in questa coda lo scheduler eleggerà per l'esecuzione sempre quello in testa, ovvero il processo che nella fase di prenotazione precedente ha indicato un tempo minore.

Per poter soddisfare le caratteristiche sopra indicate è risultato naturale impostare l'entità scheduler come attiva.
Questa componente ha quindi la funzione di eliminare la parte indesiderata di concorrenza presente nel sistema, per rendere predicibile e controllata l'evoluzione del sistema.
\subsection*{Interfaccia Fornita}
Lo scheduler deve fornire un metodo \fun{queue\_work} che permette alle altre entità attive di effettuare la procedura di booking precedentemente descritta.
Il metodo \fun{set\_speedup} serve a regolare la velocità con cui evolve la simulazione, mentre i metodi \fun{start\_simulation} e \fun{pause\_simulation} servono rispettivamente ad avviare e fermare momentaneamente la simulazione.
\subsection*{Interfaccia Richiesta}
Nessuna.

\section{Track}
La componente track è stata pensata per incapsulare i dati relativi al circuito di gara e le regole di percorrenza del medesimo. Dal punto di vista progettuale track è sicuramente un'entità reattiva, in particolare una risorsa protetta con agente di controllo passivo.
I dati relativi alla configurazione della pista utilizzati dal sistema sono derivati dalle informazioni inserite dall'utente tramite file di configurazione.

La componente track deve contenere due gruppi di dati, uno riguardo le informazioni che possono essere considerate costanti poiché non variano nell'arco della competizione, l'altro comprendente i dati dinamici come la posizione delle vetture durante la gara.
La rappresentazione interna della pista è gestita come una lista di segmenti ciascuno dei quali contiene le seguenti informazioni:
\begin{itemize}
\item lunghezza del tratto,
\item ampiezza del segmento (espressa come numero di corsie),
\item inclinazione,
\item raggio di curvatura (nel caso in cui il segmento sia una curva).
\end{itemize}
Associate ai segmenti si hanno informazioni dinamiche riguardanti lo stato della pista come le condizioni atmosferiche al suolo (che può variare nel corso della competizione).
Un altro gruppo di informazioni dinamiche fondamentali contenute in track è quello relativo alle auto durante la competizione, per ogni auto infatti sono presenti:
\begin{itemize}
\item segmento che sta percorrendo,
\item tempo e corsia di ingresso,
\item tempo e corsia di uscita,
\item velocità di uscita.
\end{itemize}

Oltre ai dati visti finora, la componente track deve anche gestire la logica che determina quali spostamenti siano concessi alle auto e soprattutto secondo quali vincoli tali spostamenti siano possibili. Deve quindi esporre un metodo che permetta alle auto di simulare l'esito di un eventuale spostamento nella pista e un metodo che invece implementi l'effettivo spostamento dell'auto. Fornire un metodo per la simulazione della mossa permette di dare dei dati al chiamante che può quindi scegliere, secondo la sua logica interna e strategia di gara, quale sia la migliore mossa da eseguire e in un momento successivo effettuare tale mossa.
\subsection*{Interfaccia Fornita}
Grazie al metodo \fun{simulate} le entità car possono simulare, una volta scelta la corsia di uscita e espressa la "volontà" o meno di effettuare una sosta in quel giro, l'esito di uno spostamento.

L'utilità di questa funzionalità è evidente se si va a considerare il fatto che, essendo l'informazione ritornata dal metodo \fun{simulate} un'informazione basata sullo stato della pista e non su stime statiche, essa viene influenzata dalla posizione delle altre auto. Una scelta statica ragionevole del percorso migliore da seguire poterebbe essere quella individuata come traiettoria ottimale a circuito vuoto, tuttavia, in questo modo tutte auto seguirebbero lo stesso percorso non riuscendo mai a sorpassarsi.

Avendo a dispozione la posizione degli altri concorrenti è invece possibile per la componente car decidere di discostarsi dalla traiettoria ottimale cambiando corsia (operazione che aumenta il tempo di percorrenza del segmento) per effettuare manovre di sorpasso qualora sia possibile e vantaggioso.

Il metodo \fun{move} necessita degli stessi parametri del metodo \fun{simulate} e serve semplicemente a spostare effettivamente l'auto sul tracciato di gara e ad effettuare le eventuali notifiche di eventi scatenati da tale spostamento.
\subsection*{Interfaccia Richiesta}
Da un punto di vista funzionale la componente track contiene la logica che guida l'erogazione delle operazioni di rifornimento, tuttavia non può decidere quali operazioni effettuare, poiché questo tipo di scelte è inerente la strategia di gara e quindi è da considerarsi a carico della componente team. Di conseguenza track necessita di un metodo \fun{pitstop\_operations} da invocare presso la componente team associata all'auto ai box che abbia come valore di ritorno informazioni su che operazioni di rifornimento da effettuare.

Durante la simulazione, nel momento in cui un'auto effettua uno spostamento, è la componente track che riconosce eventi come un sorpasso o l'attraversamento di un intermedio cronometrico e deve provvedere ad inviare tali notifiche al sistema. La componente track non deve tuttavia incaricarsi di notificare direttamente tali eventi a chi interessato ma, come previsto dall'architettura di sistema, si limita ad inviare le notifiche alla componente event dispatcher e delega a quest'ultima la propagazione di tali informazioni nel sistema.
Le notifiche possibili riguardano:
\begin{itemize}
\item sosta ai box ed operazioni effettuate,
\item ritiro dalla gara di un'auto,
\item attraversamento di un intermedio cronometrico,
\item sorpasso,
\item fine della gara.
\end{itemize}

\section{Car}
Car è un'entità attiva e rappresenta nel contesto del progetto un'auto che partecipa alla competizione. Ad ogni istanza di questa componente presente nel sistema saranno associate queste informazioni:
\begin{itemize}
\item numero identificativo,
\item nome del pilota,
\item abilità del pilota,
\item peso del pilota,
\item scuderia di appartenenza,
\item livello di carburante nell'auto,
\item tipo di pneumatici utilizzati,
\item livello di usura dei pneumatici,
\item posizione nel circuito.
\end{itemize}
Prima dell'inizio della competizione car deve prenotarsi presso lo scheduler e stare poi in attesa del permesso di muoversi sulla pista dato dello scheduler.
Questa componente ha il compito di decidere quale traiettoria adottare per percorrere un segmento e deve farlo basandosi sullo stato dell'auto, sulle direttive dei team e dell'utente e sulle informazioni fornite da track.
\subsection*{Interfaccia Fornita}
L'autorizzazione a muoversi sul circuito di gara viene data a questa componente dallo scheduler attraverso l'invocazione del metodo \fun{move}. L'esecuzione di questo metodo è divisa in due fasi:
\begin{itemize}
\item simulazione, ovvero la fase in cui car utilizza l'interfaccia fornita dalla componente track per simulare tutte le mosse consentite e decidere, secondo la logica che governa la strategia di gara del pilota, quale tra le possibili traiettorie adottare.
\item spostamento, consiste nel segnalare a track la mossa deciso dall'auto e, a fronte delle conseguenze che tale spostamento comporta, prenotarsi nuovamente presso lo scheduler nel caso in cui la mossa vada a buon fine, ritirarsi altrimenti.
\end{itemize}

Per permettere la comunicazione della strategia di gara tra team e car, la presente componente deve esporre nella sua interfaccia un metodo \fun{set\_next\_pitstop} che serve alla scuderia per comunicare al pilota in quale giro recarsi ai box per il rifornimento.

L'utente può anche decidere di forzare il pilota ad effettuare mosse non previste dalla strategia di gara e che non possono essere modificate se non dall'utente stesso, in particolare può:
\begin{itemize}
\item imporre una sosta ai box il prima possibile, per questo viene fornito il metodo \fun{force\_pitstop},
\item forzare il ritiro dalla competizione di un'auto, a tale scopo viene esposto in interfaccia il metodo \fun{retire}.
\end{itemize}
\subsection*{Interfaccia Richiesta}
Questa componente necessita delle funzionalità \fun{simulate} (fase di simulazione) e \fun{move} (fase di spostamento) fornite dalla componente track per poter realizzare il metodo \fun{move} prima descritto.
Durante la fase di inizializzazione del sistema ogni componente car deve notificare i dati di interesse relativi alla sua configurazione al resto del sistema. Questo viene ottenuto grazie al canale \fun{notify} fornito dal event dispatcher.
\section{Team}
Questa componente nel contesto della simulazione rappresenta le scuderie in gara. Team deve quindi ricevere i dati relativi alle prestazioni delle proprie auto e allo stato della pista, elaborare una strategia di rifornimento e comunicare alle auto quando recarsi ai box.

Le decisioni che la logica di questa componente deve prendere sono inerenti le operazioni da eseguire in fase di rifornimento e comprendono la quantità di carburante aggiuntivo da imbarcare e se sostituire o meno i pneumatici ed eventualmente il tipo più appropriato alle condizioni atmosferiche della pista.
\subsection*{Interfaccia Fornita}
Team espone il metodo \fun{pitstop\_operations} nella sua interfaccia con lo scopo di fornire alla componente track, durante la fase di sosta ai box di un'auto, le informazioni necessarie ad effettuare le operazioni di rifornimento.

Il metodo \fun{update} serve a fornire un canale di comunicazione che l'event dispatcher usa per la notifica di eventi relativi alla gara considerati importanti per le scuderie.
\subsection*{Interfaccia Richiesta}
Per poter comunicare la strategia di gara decisa alle auto appartenenti alla scuderia rappresentata, questa componente necessita del metodo \fun{set\_next\_pitstop} fornito da car.
Come la componente car anche team deve comunicare le proprie informazioni di configurazione al sistema tramite il metodo \fun{notify} del event dispatcher.
\section{Event Dispatcher}
Questa componente ha il compito di ricevere tutti i dati relativi alla competizione e, dopo una eventuale rielaborazione, inviare tali dati alle componenti interessate.

Questo tipo di comunicazione segue il modello publish/subscribe ed è quindi previsto che le componenti del sistema interessate a tali dati effettuino prima la procedura di subscription (ricevendo se necessario lo stato attuale della competizione) per poi ottenere aggiornamenti con l'evolvere della gara. I subscribers devono indicare che informazioni desiderano ricevere di modo che l'event dispatcher possa effettuare una procedura di filtering per evitare l'invio di dati non necessari.

Viste le caratteristiche che deve avere tale componente, nell'ottica di un sistema distribuito, possiamo considerarla un server.
\subsection*{Interfaccia Fornita}
Il dispatcher deve fornire metodi di interfaccia verso due insiemi di attori:
\begin{itemize}
\item subscribers, ovvero i processi che si registrano per ottenere le informazioni riguardanti la gara attraverso il metodo \fun{subscribe},
\item notifiers, ovvero quei processi che scatenano eventi inerenti la competizione e delegano la notifica al sistema di tali eventi all'event dispatcher tramite l'invocazione del metodo \fun{notify}.
\end{itemize}
Il metodo \fun{subscribe} prevede che il processo chiamante indichi tra i parametri anche una funzione di callback che faccia da canale per l'invio delle notifche di gara.

\subsection*{Interfaccia Richiesta}
Da un punto di vista puramente pratico non vi è nessuna interfaccia richiesta da questa componente poiché il dispatcher, in assenza di observers, non effettua invocazioni di metodi. Tuttavia abbiamo preferito considerare l'interfaccia richiesta come dinamica, ovvero iniziamlemente vuota e che acquisisce metodi all'aumentare del numero di subscribers. Al momento della registrazione i subscribers devono indicare al dispatcher quale metodo di callback utilizzare e che va quindi ad aggiungersi all'interfaccia richiesta della presente componente.
\section{Weather}
Weather è la componente del sistema addetta a gestire le condizioni meteo iniziali sulla pista e le variazioni di tali condizioni durante la competizione. Le variazioni alla situazione meteo sono decise dall'utente tramite file di configurazione e possono essere decise a simulazione avviata in modo asincrono tramite interfaccia utente.

Poiché questa entità attiva va a modificare lo stato della pista, essa è evidentemente in concorrenza con le entità car presenti nel sistema. E' pertanto necessario che l'accesso alla risorsa track avvenga in modo controllato, in particolare è previsto che le modifiche sulla pista avvengano attraverso booking presso lo scheduler.
\subsection*{Interfaccia Fornita}
Al momento della prenotazione presso lo scheduler questa componente indica il metodo \fun{apply\_change} come metodo di callback, di conseguenza, nel momento in cui lo scheduler permetterà a questa entità di eseguire invocherà tale metodo. Questo metodo ha il compito di cambiare il tempo atmosferico di track secondo quanto definito dall'utente.
L'altro metodo che l'interfaccia di weather espone è \fun{schedule\_change} che serve per impostare eventuali variazioni nel tempo atmosferico da parte dell'utente a simulazione avviata.
\subsection*{Interfaccia Richiesta}
Conformemente a quanto visto finora anche la modifica del tempo atmosferico necessita dell'autorizzazione dello scheduler per essere portata a termine poiché modifica lo stato di track. Di conseguenza tutte le modifiche saranno procedute da un'invocazione del metodo \fun{queue\_work} dello scheduler per assolvere alla fase di prenotazione.

Le condizioni atmosferiche sono un fattore importante per la simulazione e una variazione delle medesime può essere di interesse a diverse componenti del sistema. Per questo motivo ogni volta che viene invocato il metodo \fun{apply\_change} viene notificata la modifica grazie al metodo \fun{notify} dell'event dispatcher.
\section{Debug Log}
Questa componente è pensata principalmente per essere d'ausilio nella fase di sviluppo e test. In fase di inizializzazione effettua la procedura di subscription presso l'event dispatcher per tutti i tipi di messaggi in modo da rendere i dati disponibili in formato testuale tramite una semplice interfaccia grafica.
\subsection*{Interfaccia Fornita}
Al fine di poter riceve le notifiche dall'event dispatcher questa componente espone in interfaccia un metodo callback che serve a ricevere le notifiche e mostrare le informazioni trasportate in forma testuale all'utente.
\subsection*{Interfaccia Richiesta}
Facendo parte del gruppo di componenti observers, debug log necessita della possibilità di registrarsi presso l'event dispatcher con il metodo \fun{subscribe}.
\section{Race Info}
Questa componente serve a raggruppare la maggior parte delle funzionalità di visualizzazione della competizione e permette inoltre all'utente di interagire con il sistema.

I dati visualizzati devono essere sufficienti all'utente per comprendere l'andamento della gara. Devono quindi essere presenti:
\begin{itemize}
\item stato della simulazione (avviata, in pausa, terminata),
\item posizione delle auto sulla pista,
\item classifica e sorpassi,
\item eventuali ritiri,
\item velocità massima,
\item tempo migliore sul giro.
\end{itemize}
Attraverso questa componente l'utente può interagire con lo stato della simulazione nei seguenti modi:
\begin{itemize}
\item avvio,
\item pausa,
\item terminazione,
\item cambio del fattore di speedup.
\end{itemize}
\subsection*{Interfaccia Fornita}
Essendo race info una GUI dal punto di vista funzionale espone sicuramente un'interfaccia verso l'utente con lo scopo di rendere facilmente fruibili i dati riguardanti l'evolvere della simulazione.
Questa componente, conformemente a quanto avviene nel resto del sistema, riceve le informazioni sulla competizione dall'event dispatcher. Per questo motivo deve fornire al dispatcher almeno un canale di comunicazione (metodo di callback).
\subsection*{Interfaccia Richiesta}
Per poter interagire con la simulazione come descritto precendentemente race info necessita di diversi metodi forniti della componente scheduler:
\begin{itemize}
\item \fun{start\_simulation},
\item \fun{pause\_simulation},
\item \fun{set\_speedup}.
\end{itemize}
Appartenendo inoltre al gruppo degli observers questa componente necessita del metodo del event dispatcher \fun{subscribe}.
\section{Team Gui}
Questa componente è un'interfaccia grafica che serve a fornire all'utente dettagli approfonditi sulle statistiche di gara delle auto appartenenti ad una scuderia.
I dati da mostrare all'utente sono:
\begin{itemize}
\item nome del pilota,
\item carburante residuo,
\item consumo medio di carburante sull'ultimo giro,
\item tipo e stato dei pneumatici,
\item usura media dei pneumatici sull'ultimo giro,
\item tempo migliore per intermedio cronometrico,
\item tempo migliore sul giro,
\item numero di pitstop effettuati,
\item operazioni effettuate durante l'ultima sosta ai box.
\end{itemize}
L'utente può inoltre forzare la sosta ai box o il ritiro per un'auto appartenente alla scuderia.
\subsection*{Interfaccia Fornita}
\subsection*{Interfaccia Richiesta}
\section{Weather Gui}
Questa componente è un'interfaccia grafica che mostra all'utente le condizioni atmosferiche sulla pista e permette a quest'ultimo di modificarle in modo asincrono rispetto alla simulazione durante il corso della competizione. Le informazioni sullo stato della pista sono ottenute dall'event dispatcher mentre le richieste di variazioni vengono inviate alla componente weather.

\subsection*{Interfaccia Fornita}
\subsection*{Interfaccia Richiesta}
\section{Avvio e Terminazione}
Infrastruttura e meccanismi di avvio e terminazione del sistema.
\section{Alternative?}
Eventualmente cassare questa sezione

\chapter{Implementazione}
\section{Tecnologie utilizzate}
Breve descizioni dei principi base ed eventuali problemi riscontrati.
\section{Dinamiche della competizione}
\subsection{Partenza}
Prima che l'utente dia il via alla competizione tutte le auto devono essersi registrate presso lo scheduler indicando come tempo di prenotazione 0.
E' importante precisare che in questa situazione l'ordine in cui lo scheduler fa eseguire i processi car non influenza l'esito della gara infatti alla partenza le auto sono tutte su segmenti diversi e di conseguenza non conocorrono tra di loro per l'accesso ad uno stesso segmento. Ne deriva quindi che sebbene l'ordine di esecuzione alla partenza possa essere considerato casuale (dipende dall'ordine di registrazione presso una componente distribuita del sistema), questo non va ad influenzare i tempi di percorrenza dei segmenti da parte delle auto e non influisce quindi con il risultato della gara.
La disposizione iniziale delle auto sulla pista avviene similmente a quanto riportato in figura \ref{fig:startGrid}, ed è richiesto all'utente che nella zona di pista che precede la linea di arrivo vi siamo almeno tre corsie.
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/StartGrid}
\caption{Griglia di Partenza}
\label{fig:startGrid}
\end{figure}
\subsection{Percorrenza di un Segmento}
Nel momento in cui un'auto si appresta a percorrere un segmento sono noti:
\begin{itemize}
\item Corsia di ingresso,
\item Velocità di ingresso,
\item Tempo di ingresso,
\item Conformazione e stato del segmento,
\item Caratteristiche e stato dell'auto,
\item Informazioni su altre auto che stanno percorrendo quel segmento.
\end{itemize}
Grazie alle informazioni sopra elencate e indicando in quale corsia il pilota vuole trovarsi all'uscita del segmento è possibile calcolare il tempo e la velocità di uscita dell'auto. Sono principalmente due i gruppi di fattori che influenzano questo calcolo: in primo luogo l'auto e le caratteristiche della pista, poi la presenza di altre auto nello stesso segmento e l'interazione che queste auto possono avere.

Iniziando ad analizzare il primo gruppo di fattori risulta evidente che vi è una velocità massima che un'auto può mantenere in un segmento per evitare di uscire di pista, in particolare nei segmenti curvilinei la forza di attrito deve essere sufficiente a contrastare la forza centrifuga.
Visto che la forza d'attrito dipende anche dalle caratteristiche e dallo stato dell'auto è evidente che tale velocità massima può essere diversa per ogni auto.
Un altro vincolo alla velocità è dato dal regolamento di gara per quanto riguarda la percorrenza della pitlane, tuttavia questo vincolo non riguarda l'intero segmento ma solo una determinata corsia e va a influire solo sulle auto che stanno per rientarare ai box per effettuare una sosta.

I segmenti appena elencati non sono tuttavia gli unici ad avere un limite alla velocità alla quale possono essere percorsi, basta pensare alle azioni che i piloti effettuano prima di intraprendere una curva nella realtà per capire che un segmento curvilineo impone vincoli alla velocità di percorrenza anche a sui segmenti che lo precedono. E' quindi corretto affermare che ogni segmento della pista ha un limite di velocità, sia esso diretto o indiretto. Il numero di segmenti che impone limiti di velocità diretti può cambiare in base al fatto che il pilota voglia o meno effetuare una sosta ai box e di conseguenza cambieranno anche i limiti indiretti. Per questo motivo abbiamo deciso di modellare questo fatto associando ad ogni segmento due limiti di velocità.

La fase in cui vengono calcolati i due limiti di velocità per ogni segmento della pista è detta fase di preelaborazione e viene effettuata da un'auto:
\begin{enumerate}
\item All'inizio della gara,
\item Ogni volta che passa per il traguardo,
\item Dopo ogni sosta ai box,
\item Dopo ogni cambio delle condizioni atmosferiche.
\end{enumerate}
Il calcolo al punto 1 avviene poiché non è possibile per un'auto effettuare una mossa senza avere una tabella di preelaborazione, al punto 2 per avere una stima più accurata dei valori necessari che consideri il livello di carburante e usura pneumatici attuale e ai punti 3 e 4 poiché in corrisponedenza di tali eventi può cambiare di molto l'attrito pneumatici/pista e invalidare quindi la preelaborazione precedente.

Nel calcolo dei limiti di velocità indiretti è molto importante la decelerazione massima che un'auto può avere per rendere la simulazione più verosimile abbiamo deciso di trattare in modo abbastanza dettagliato la parte fisica della competizione facendo dipendere accelerazione e decelazione massime di un'auto sia dalle caratteristiche dell'auto che da quelle della pista.
In particolare l'accelerazione/decelerazione che un auto può erogare in un determinato segmento dipende da:
\begin{itemize}
\item Potenza del motore/dei freni,
\item Peso dell'auto a secco,
\item Peso del pilota,
\item Peso del carburante,
\item Stato di usura e tipo dei pneumatici,
\item Condizioni atmosferiche,
\item Inclinazione della pista.
\end{itemize}

Passiamo ora a descrivere le operazioni che il processo car effettua nel momento in cui lo scheduler gli consente di eseguire una mossa.
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/Simulation}
\caption{Fase di Simulazione}
\label{fig:simulation}
\end{figure}
Come si può vedere in figura \ref{fig:simulation}, la prima operazione che viene effettuata è l'eventuale ricalcolo della tabella di preelaborazione, successivamente viene controllato se è prevista una sosta ai box per il giro corrente e poi si passa alla fase di simulazione.
Nella fase di simulazione car richiede a track quali sono le corsie raggiungibili nel segmento che sta per percorrere e successivamente di simulare l'esito dello spostamento per ogni corsia che l'auto può raggiungere.
La fase di simulazione, implementata con l'invocazione di track:simulate, può ritornare diversi risultati a car:
\begin{itemize}
\item race\_ended: l'auto nella mossa precedente ha superato il traguardo nell'ultimo giro e ha quindi terminato la sua gara,
\item fail: l'auto non può effettuare la mossa richiesta poiché:
  \begin{itemize}
  \item ha esaurito il carburante;
  \item i pneumatici sono esplosi per l'eccessiva usura,
  \item i team hanno ordinato il ritiro dell'auto dalla competizione,
  \item non è possibile usare la corsia richiesta poiché il regolamento lo vieta,
  \item si sta cercando di entrare nella pitlane senza aver segnalato la sosta,
  \item la corsia che si vuole usare è già occupata e la capacità di frenata dell'auto non è sufficiente ad accodarsi all'auto che la precede,
  \item l'auto non è in grado di mantenersi in pista a causa della velocità eccessiva.
  \end{itemize}
\item pits: l'auto effettuerà una sosta ai box,
\item Time: il tempo in cui l'auto uscirà da quel segmento calcolato come tempo di ingresso più tempo di percorrenza.
\end{itemize}
Una volta ottenuti i risultati della simulazione la logica di car decide quale sia la corsia migliore per effettuare lo spostamento, in particolare l'auto sceglierà la corsia la cui simulazione ritorna il valore (in ordine di priorità):
\begin{itemize}
\item race\_ended,
\item pits,
\item il valore Time minore,
\item fail.
\end{itemize}

\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/Move}
\caption{Fase di Spostamento}
\label{fig:move}
\end{figure}

Una volta scelta la corsia migliore car effettua lo spostamento sulla pista grazie all'invocazione track:move (figura \ref{fig:move}) e resta in attesa del risultato che può essere o il tempo di uscita dal segmento che si sta percorrendo oppure race\_ended oppure fail. Nel primo caso l'auto provvederà a prenotarsi presso lo scheduler indicando il tempo di uscita, negli altri casi car non effetturà alcuna prenotazione.

La fase di spostamento nella prima parte è molto simile alla fase di simulazione poiché viene controllato se la mossa è consentita o meno e viene eventualmente calcolato il tempo di uscita anche nel caso in cui si tratti di una sosta ai box. Nella seconda parte dello spostamento vengono emesse eventuali notifiche verso il dispatcher.

Il metodo move\_car è particolamente importante ai fini della simulazione poiché serve a individuare eventuali sorpassi avvenuti all'interno del segmento e notificarli. Individuare le auto sorpassate a seguito della mossa che un'auto (chiamiamola A) sta effettuando è semplice: detto $T_{en_X}$ il tempo di ingresso di un'auto X nel segmento e $T_{ex_X}$ il suo tempo di uscita, l'insieme delle auto $\mathcal{S}$ sorpassate da A in quel segmento sarà:
\begin{center}
$\mathcal{S} = \{ X \; | \; T_{en_X} \leq T_{en_A} \; \wedge \; T_{ex_X} > T_{ex_A}\}$
\end{center}
Oltre a ciò deve anche calcolare i consumi dell'auto derivanti dall'aver percorso quel segmento.
Il consumo di carburante è pari a una quantità fissa per segmento moltiplicata per un coefficiente derivante dall'inclinazione della pista in quel punto, mentre il consumo dei pneumatici dipende dalla curvatura del segmento, dal tipo di pneumatici usati e dalle condizioni atmosferiche.

\begin{center}
\begin{figure}
\includegraphics[width=0.5\textwidth]{diagrammi/Surpass}
\caption{Interazione tra auto nello stesso segmento}
\label{fig:surpass}
\end{figure}
\end{center}
La figura \ref{fig:surpass} rappresenta le situazioni che si possono creare nel momento in cui un'auto percorre un segmento di pista in cui è presente un altra auto.

Nel momento in cui l'auto A effettua il suo turno sono noti:
\begin{itemize}
\item $T_{en_B}^{n+1}$: il tempo di ingresso di B nel segmento $n+1$,
\item $T_{ex_B}^{n+1}$: il tempo di uscita di B dal segmento $n+1$,
\item $L_{en_B}^{n+1}$: la corsia di ingresso di B nel segmento $n+1$,
\item $L_{ex_B}^{n+1}$: la corsia di uscita di B dal segmento $n+1$,
\item $T_{en_A}^{n+1}$: il tempo di ingresso di A nel segmento $n+1$,
\item $L_{en_A}^{n+1}$: la corsia di ingresso di A nel segmento $n+1$,
\item $L_{ex_A}^{n+1}$: la corsia di uscita di A dal segmento $n+1$ (scelta dall'auto quindi si può considerare fissata).
\end{itemize}
L'algoritmo deve quindi calcolare $T_{ex_A}^{n+1}$.
$T_{lc}$ è il tempo che un'auto impega a spostarsi da una corsia ad una adiacente è considerato fisso ed uguale per tutte le auto, ogni auto può spostarsi di una sola corsia per ogni segmento e, per semplificare la simulazione, si assume che lo spostamento venga effettuato solamente all'ingresso del segmento.
Come precodizione si ha inoltre che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1}$ poiché B si è spostata in quel segmento prima di A e che $T_{en_A}^{n+1} \leq T_{ex_B}^{n+1}$ altrimenti lo scheduler eleggerebbe B per l'esecuzione.

Per poter calcolare il tempo di uscita di A dal segmento $n+1$ è necessario prima valutare se B interferisce con la mossa di A.
Considerando la situazione (a) di figura \ref{fig:surpass} possiamo distinguere due casi:
\begin{enumerate}
\item $L_{ex_A}^{n+1} = m+2$: non vi è alcuna interferenza da parte di B poiché la corsia $m+2$ è libera,
\item $L_{ex_A}^{n+1} = m+1$:
  \begin{enumerate}
  \item $L_{en_B}^{n+1} = m+2$: A sta seguendo esattamente la stessa traiettoria che ha seguito B per percorrere il segmento $n+1$ ed è quindi corretto che a l'auto A si accodi a B e non possa superarla,
  \item $L_{en_B}^{n+1} = m+1$: A cerca di inserirsi davanti a B tagliandole la strada tuttavia, visto che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1}$, vale anche che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1} + T_{lc}$ e non è quindi possibile che A si posizioni davanti a B.
  \item $L_{en_B}^{n+1} = m$: A e B si spostano entrambe sulla stessa corsia $m+1$ provenendo da corsie differenti ma visto che $T_{en_B}^{n+1} \leq T_{en_A}^{n+1}$ allora vale anche $T_{en_B}^{n+1} + T_{lc} \leq T_{en_A}^{n+1} + T_{lc}$ e di conseguenza A può solo accodarsi a B.
  \end{enumerate}
\end{enumerate}

Per quanto riguarda la situazione (b) di figura \ref{fig:surpass} vi sono due casi:
\begin{enumerate}
\item $L_{ex_A}^{n+1} = m+2$ o $L_{ex_A}^{n+1} = m$: non vi è alcuna interferenza da parte di B poiché le corsie sono libere,
\item $L_{ex_A}^{n+1} = m+1$:
  \begin{enumerate}
  \item $L_{en_B}^{n+1} = m+1$: A si accoda a B (vedi caso 1(a) della situazione (a)),
  \item $L_{en_B}^{n+1} = m+2$ o $L_{en_B}^{n+1} = m$: A cerca di inserirsi davanti a B prima che questa le ha tagli la strada e se $T_{en_B}^{n+1} + T_{lc} < T_{en_A}^{n+1}$ vuol dire che non ci riesce e deve quindi accodarsi a B, altrimenti vuol dire che riesce a rimanere in testa e non viene quindi influenzata dalla presenza di B.
  \end{enumerate}
\end{enumerate}

Nei casi in cui non vi è interferenza da parte di B nella mossa di A, $T_{ex_A}^{n+1}$ viene calcolato solo sulla base delle caretteristiche dell'auto e della pista.
Nei casi in cui A deve accodarsi a B viene aggiunto il vincolo che $T_{ex_A}^{n+1} > T_{ex_B}^{n+1}$ e calcolata la velocità di uscita di conseguenza.

\subsection{Intermedi Cronometrici}
Gli intermedi cronometrici e il traguardo sono dei particolari segmenti a lunghezza zero, dal punto di vista di car sono trattati esattamente come tutti gli altri segmenti in quanto è compito di track nascondere le differenze ed effettuare semplificazioni dove possibile. Avendo lunghezza zero non è necessario effettuare il calcolo del tempo di percorrenza infatti per questo tipo di segmenti vale, detto $n+1$ l'indice di tale segmento:
\begin{itemize}
\item $L_{ex_A}^{n} = L_{ex_A}^{n+1}$: imposto dal modulo access poiché non è possibile cambiare corsia in un segmento di lunghezza nulla,
\item $T_{ex_A}^{n} = T_{en_A}^{n+1} = T_{ex_A}^{n+1}$: poiché il tempo impegato a percorrere un tratto di lunghezza nulla è nullo,
\item la velocità di uscita dal segmento $n+1$ è uguale alla velocità di ingresso nel medesimo segmento,
\item non possono avvenire sorpassi all'interno di tale segmento,
\item il percorrere tale segmento non causa consumo né di carburante né di pneumatici.
\end{itemize}
Come si può notare in figura \ref{fig:move} in corrispondenza del transito di un'auto attraverso un intermedio cronometrico viene emessa da track una chrono\_notif verso il dispatcher. Questo tipo di messaggio contiene:
\begin{itemize}
\item ID dell'auto,
\item ID dell'intermedio e numero del giro,
\item tempo di gara in cui l'auto attraversa l'intermedio,
\item velocità massima raggiunta dall'auto dopo l'intermedio precedente,
\item stato carburante e pneumatici dell'auto.
\end{itemize}
\subsection{Pit Lane}
\begin{center}
\begin{figure}
\includegraphics[width=\textwidth]{diagrammi/PitLane}
\caption{Rappresentazione della zona dei box}
\label{fig:pitLane}
\end{figure}
\end{center}

La sezione di pista indicata dall'utente come zona box attraverso l'impostazione di pitlane\_entrance e pitlane\_exit nel file di configurazione viene rappresentata dalla componente track come mostra la figura \ref{fig:pitLane}. Le corsie con indice maggiore o uguale a n sono quelle indicate dall'utente nel file di configurazione mentre le corsie -1 e -2 sono generate in modo automatico in fase di costruzione della pista.

Per ogni team che partecipa alla simulazione viene risevata una zona box diversa della pista (indicata in figura come team area) formata da due segmenti di tipo pitlane e uno di tipo pitstop. Per poter effettuare il rifornimento un'auto deve trovarsi nella corsia di indice -2 del segmento pitstop associato alla sua scuderia.

I segmenti di tipo pre\_pitlane, post\_pitlane, pitlane e pitstop sono soggetti a regole di percorrenza aggiuntive definite nel modulo access:
\begin{itemize}
\item pre\_pitlane: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n,
\item post\_pitlane: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n e viceversa,
\item pitlane: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n e viceversa,
\item pitstop: non è possibile effettuare uno spostamento dalla corsia -1 verso la corsia n e viceversa, inoltre un'auto non può accedere alla corsia -2 dei segmenti pitstop appartenenti ad altre scuderie.
\end{itemize}

Il regolamento delle gare di formula uno impone un limite di velocità nella corsia dei box, nel caso della simulazione questo limite è applicato nelle corsie di indice -1 e -2 dei segmenti di tipo pitlane e pitstop ed è imposto alle auto nel calcolo della velocità massima eseguito in fase di preelaborazione come precedentemente descritto.
La corsia aggiuntiva nei segmenti di tipo pre\_pitlane e post\_pitlane serve a rappresentare rispettivamente la corsia di decelerazione e la corsia di accelerazione e non sono quindi soggette a particolari limiti di velocità imposti dal regolamento.

\subsection{Rifornimento}
Per poter effettuare le operazioni di rifornimento e cambio pneumatici un'auto deve trovarsi a percorrere il segmento pitstop associato alla sua scuderia nella corsia di indice -2. Quando car effettua uno spostamento in tale posizione (vedi \fun{track:move}) è la componente track che si incarica di effettuare la chiamata alla componente team associata all'auto per richiedere quali operazioni siano da effettuare sull'auto durante la sosta.

Track invia quindi lo stato carburante e pneumatici dell'auto al team il quale risponde con un messaggio contenente quanto carburante aggiungere e quale tipo di pneumatici montare in caso di cambio gomme, il tutto tramite l'invocazione del metodo \fun{pitstop\_operations} di team.

Le componenti team sono in grado di calcolare questi valori sulla base dei dati ottenuti tramite il dispatcher e derivanti dalle crono\_notif, grazie a questo meccanismo team riesce a calcolare il consumo di carburante e gomme medio sul giro per ogni auto e ad adottare quindi una strategia di rifornimento ragionevole.
Il tempo necessario ad effettuare le operazioni è calcolato da track in base alle operazioni da effettuare.

Visto che ogni scuderia può rifornire una sola auto alla volta il tempo di uscita dell'auto A è calcolato come segue:
\begin{center}
$T_{ex_A} = max(T_{en_A}, T_{ex_B}) + T_{ops}$
\end{center}
dove B è l'auto accodata nello stesso segmento e in corsia -2 con tempo di uscita maggiore (ovvero l'auto che eventuamente precede A nella sosta ai box) e $T_{ops}$ è il tempo necessario ad effettuare le operazioni di rifornimento.
\subsection{Arrivo}
Termiazione dei processi car
\subsection{Interazione con l'Utente}

\section{Correttezza}
Considerazioni sulla correttezza del tempo di percorrenza, controllo della concorrenza, algoritmo di sorpasso.
Rallentamento della simulazione non influenza i tempi di gara (scheduler).
\appendix

\chapter{Glossario}

\begin{tabularx}{\textwidth}{lX}
\term{Intermedio cronometrico}{}
\term{Tabella di preelaborazione}{Struttura dati riferita ad un'auto in cui sono contenute le triple (ID segmento, velocità massima, velocità massima con pitstop) per ogni segmento della pista.}
\term{Segmento}{L'unità di spazio più piccola e indivisibile che costituisce il tracciato, utilizzata per la rappresentazione interna dello stesso.}
\term{Settore}{Porzione di tracciato che presenta caratteristiche fisiche costanti per tutta la sua lunghezza. Definito dall'utente in fase di configurazione.}
\term{Speedup}{Fattore numerico che serve ad impostare la velocità con la quale la simulazione evolve.}
\end{tabularx}

\end{document}
